import {
  __commonJS
} from "./chunk-UV5CTPV7.js";

// node_modules/react-component/lib/DOMProperty.js
var require_DOMProperty = __commonJS({
  "node_modules/react-component/lib/DOMProperty.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var DOMPropertyInjection = {
      /**
       * Mapping from normalized, camelcased property names to a configuration that
       * specifies how the associated DOM property should be accessed or rendered.
       */
      MUST_USE_ATTRIBUTE: 1,
      MUST_USE_PROPERTY: 2,
      HAS_SIDE_EFFECTS: 4,
      HAS_BOOLEAN_VALUE: 8,
      HAS_POSITIVE_NUMERIC_VALUE: 16,
      /**
       * Inject some specialized knowledge about the DOM. This takes a config object
       * with the following properties:
       *
       * isCustomAttribute: function that given an attribute name will return true
       * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
       * attributes where it's impossible to enumerate all of the possible
       * attribute names,
       *
       * Properties: object mapping DOM property name to one of the
       * DOMPropertyInjection constants or null. If your attribute isn't in here,
       * it won't get written to the DOM.
       *
       * DOMAttributeNames: object mapping React attribute name to the DOM
       * attribute name. Attribute names not specified use the **lowercase**
       * normalized name.
       *
       * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
       * Property names not specified use the normalized name.
       *
       * DOMMutationMethods: Properties that require special mutation methods. If
       * `value` is undefined, the mutation method should unset the property.
       *
       * @param {object} domPropertyConfig the config as described above.
       */
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(
            domPropertyConfig.isCustomAttribute
          );
        }
        for (var propName in Properties) {
          require_React().__DEV__ === true ? invariant(
            !DOMProperty.isStandardName[propName],
            "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",
            propName
          ) : invariant(!DOMProperty.isStandardName[propName]);
          DOMProperty.isStandardName[propName] = true;
          var lowerCased = propName.toLowerCase();
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
          var attributeName = DOMAttributeNames[propName];
          if (attributeName) {
            DOMProperty.getPossibleStandardName[attributeName] = propName;
          }
          DOMProperty.getAttributeName[propName] = attributeName || lowerCased;
          DOMProperty.getPropertyName[propName] = DOMPropertyNames[propName] || propName;
          var mutationMethod = DOMMutationMethods[propName];
          if (mutationMethod) {
            DOMProperty.getMutationMethod[propName] = mutationMethod;
          }
          var propConfig = Properties[propName];
          DOMProperty.mustUseAttribute[propName] = propConfig & DOMPropertyInjection.MUST_USE_ATTRIBUTE;
          DOMProperty.mustUseProperty[propName] = propConfig & DOMPropertyInjection.MUST_USE_PROPERTY;
          DOMProperty.hasSideEffects[propName] = propConfig & DOMPropertyInjection.HAS_SIDE_EFFECTS;
          DOMProperty.hasBooleanValue[propName] = propConfig & DOMPropertyInjection.HAS_BOOLEAN_VALUE;
          DOMProperty.hasPositiveNumericValue[propName] = propConfig & DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE;
          require_React().__DEV__ === true ? invariant(
            !DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName],
            "DOMProperty: Cannot require using both attribute and property: %s",
            propName
          ) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]);
          require_React().__DEV__ === true ? invariant(
            DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName],
            "DOMProperty: Properties that have side effects must use property: %s",
            propName
          ) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]);
          require_React().__DEV__ === true ? invariant(
            !DOMProperty.hasBooleanValue[propName] || !DOMProperty.hasPositiveNumericValue[propName],
            "DOMProperty: Cannot have both boolean and positive numeric value: %s",
            propName
          ) : invariant(!DOMProperty.hasBooleanValue[propName] || !DOMProperty.hasPositiveNumericValue[propName]);
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: "data-reactid",
      /**
       * Checks whether a property name is a standard property.
       * @type {Object}
       */
      isStandardName: {},
      /**
       * Mapping from lowercase property names to the properly cased version, used
       * to warn in the case of missing properties.
       * @type {Object}
       */
      getPossibleStandardName: {},
      /**
       * Mapping from normalized names to attribute names that differ. Attribute
       * names are used when rendering markup or with `*Attribute()`.
       * @type {Object}
       */
      getAttributeName: {},
      /**
       * Mapping from normalized names to properties on DOM node instances.
       * (This includes properties that mutate due to external factors.)
       * @type {Object}
       */
      getPropertyName: {},
      /**
       * Mapping from normalized names to mutation methods. This will only exist if
       * mutation cannot be set simply by the property or `setAttribute()`.
       * @type {Object}
       */
      getMutationMethod: {},
      /**
       * Whether the property must be accessed and mutated as an object property.
       * @type {Object}
       */
      mustUseAttribute: {},
      /**
       * Whether the property must be accessed and mutated using `*Attribute()`.
       * (This includes anything that fails `<propName> in <element>`.)
       * @type {Object}
       */
      mustUseProperty: {},
      /**
       * Whether or not setting a value causes side effects such as triggering
       * resources to be loaded or text selection changes. We must ensure that
       * the value is only set if it has changed.
       * @type {Object}
       */
      hasSideEffects: {},
      /**
       * Whether the property should be removed when set to a falsey value.
       * @type {Object}
       */
      hasBooleanValue: {},
      /**
       * Whether the property must be positive numeric or parse as a positive
       * numeric and should be removed when set to a falsey value.
       * @type {Object}
       */
      hasPositiveNumericValue: {},
      /**
       * All of the isCustomAttribute() functions that have been injected.
       */
      _isCustomAttributeFunctions: [],
      /**
       * Checks whether a property name is a custom attribute.
       * @method
       */
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      /**
       * Returns the default property value for a DOM property (i.e., not an
       * attribute). Most default values are '' or false, but not all. Worse yet,
       * some (in particular, `type`) vary depending on the type of element.
       *
       * TODO: Is it better to grab all the possible properties when creating an
       * element to avoid having to create the same element twice?
       */
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  }
});

// node_modules/react-component/lib/escapeTextForBrowser.js
var require_escapeTextForBrowser = __commonJS({
  "node_modules/react-component/lib/escapeTextForBrowser.js"(exports, module) {
    "use strict";
    var ESCAPE_LOOKUP = {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#x27;",
      "/": "&#x2f;"
    };
    var ESCAPE_REGEX = /[&><"'\/]/g;
    function escaper(match) {
      return ESCAPE_LOOKUP[match];
    }
    function escapeTextForBrowser(text) {
      return ("" + text).replace(ESCAPE_REGEX, escaper);
    }
    module.exports = escapeTextForBrowser;
  }
});

// node_modules/react-component/lib/memoizeStringOnly.js
var require_memoizeStringOnly = __commonJS({
  "node_modules/react-component/lib/memoizeStringOnly.js"(exports, module) {
    "use strict";
    function memoizeStringOnly(callback) {
      var cache = {};
      return function(string) {
        if (cache.hasOwnProperty(string)) {
          return cache[string];
        } else {
          return cache[string] = callback.call(this, string);
        }
      };
    }
    module.exports = memoizeStringOnly;
  }
});

// node_modules/react-component/lib/copyProperties.js
var require_copyProperties = __commonJS({
  "node_modules/react-component/lib/copyProperties.js"(exports, module) {
    function copyProperties(obj, a, b, c, d, e, f) {
      obj = obj || {};
      if (require_React().__DEV__ === true) {
        if (f) {
          throw new Error("Too many arguments passed to copyProperties");
        }
      }
      var args = [a, b, c, d, e];
      var ii = 0, v;
      while (args[ii]) {
        v = args[ii++];
        for (var k in v) {
          obj[k] = v[k];
        }
        if (v.hasOwnProperty && v.hasOwnProperty("toString") && typeof v.toString != "undefined" && obj.toString !== v.toString) {
          obj.toString = v.toString;
        }
      }
      return obj;
    }
    module.exports = copyProperties;
  }
});

// node_modules/react-component/lib/emptyFunction.js
var require_emptyFunction = __commonJS({
  "node_modules/react-component/lib/emptyFunction.js"(exports, module) {
    var copyProperties = require_copyProperties();
    function makeEmptyFunction(arg) {
      return function() {
        return arg;
      };
    }
    function emptyFunction() {
    }
    copyProperties(emptyFunction, {
      thatReturns: makeEmptyFunction,
      thatReturnsFalse: makeEmptyFunction(false),
      thatReturnsTrue: makeEmptyFunction(true),
      thatReturnsNull: makeEmptyFunction(null),
      thatReturnsThis: function() {
        return this;
      },
      thatReturnsArgument: function(arg) {
        return arg;
      }
    });
    module.exports = emptyFunction;
  }
});

// node_modules/react-component/lib/warning.js
var require_warning = __commonJS({
  "node_modules/react-component/lib/warning.js"(exports, module) {
    "use strict";
    var emptyFunction = require_emptyFunction();
    var warning = emptyFunction;
    if (require_React().__DEV__ === true) {
      warning = function(condition, format) {
        var args = Array.prototype.slice.call(arguments, 2);
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          var argIndex = 0;
          console.warn("Warning: " + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
      };
    }
    module.exports = warning;
  }
});

// node_modules/react-component/lib/DOMPropertyOperations.js
var require_DOMPropertyOperations = __commonJS({
  "node_modules/react-component/lib/DOMPropertyOperations.js"(exports, module) {
    "use strict";
    var DOMProperty = require_DOMProperty();
    var escapeTextForBrowser = require_escapeTextForBrowser();
    var memoizeStringOnly = require_memoizeStringOnly();
    var warning = require_warning();
    function shouldIgnoreValue(name, value) {
      return value == null || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasPositiveNumericValue[name] && (isNaN(value) || value < 1);
    }
    var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
      return escapeTextForBrowser(name) + '="';
    });
    if (require_React().__DEV__ === true) {
      reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      warnedProperties = {};
      warnUnknownProperty = function(name) {
        if (reactProps[name] || warnedProperties[name]) {
          return;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName[lowerCasedName];
        require_React().__DEV__ === true ? warning(
          standardName == null,
          "Unknown DOM property " + name + ". Did you mean " + standardName + "?"
        ) : null;
      };
    }
    var reactProps;
    var warnedProperties;
    var warnUnknownProperty;
    var DOMPropertyOperations = {
      /**
       * Creates markup for the ID property.
       *
       * @param {string} id Unescaped ID.
       * @return {string} Markup string.
       */
      createMarkupForID: function(id) {
        return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) + escapeTextForBrowser(id) + '"';
      },
      /**
       * Creates markup for a property.
       *
       * @param {string} name
       * @param {*} value
       * @return {?string} Markup string, or null if the property was invalid.
       */
      createMarkupForProperty: function(name, value) {
        if (DOMProperty.isStandardName[name]) {
          if (shouldIgnoreValue(name, value)) {
            return "";
          }
          var attributeName = DOMProperty.getAttributeName[name];
          if (DOMProperty.hasBooleanValue[name]) {
            return escapeTextForBrowser(attributeName);
          }
          return processAttributeNameAndPrefix(attributeName) + escapeTextForBrowser(value) + '"';
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return "";
          }
          return processAttributeNameAndPrefix(name) + escapeTextForBrowser(value) + '"';
        } else if (require_React().__DEV__ === true) {
          warnUnknownProperty(name);
        }
        return null;
      },
      /**
       * Sets the value for a property on a node.
       *
       * @param {DOMElement} node
       * @param {string} name
       * @param {*} value
       */
      setValueForProperty: function(node, name, value) {
        if (DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(name, value)) {
            this.deleteValueForProperty(node, name);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.setAttribute(DOMProperty.getAttributeName[name], "" + value);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            if (!DOMProperty.hasSideEffects[name] || node[propName] !== value) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            node.setAttribute(name, "" + value);
          }
        } else if (require_React().__DEV__ === true) {
          warnUnknownProperty(name);
        }
      },
      /**
       * Deletes the value for a property on a node.
       *
       * @param {DOMElement} node
       * @param {string} name
       */
      deleteValueForProperty: function(node, name) {
        if (DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, void 0);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            var defaultValue = DOMProperty.getDefaultValueForProperty(
              node.nodeName,
              propName
            );
            if (!DOMProperty.hasSideEffects[name] || node[propName] !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if (require_React().__DEV__ === true) {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  }
});

// node_modules/react-component/lib/keyMirror.js
var require_keyMirror = __commonJS({
  "node_modules/react-component/lib/keyMirror.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      require_React().__DEV__ === true ? invariant(
        obj instanceof Object && !Array.isArray(obj),
        "keyMirror(...): Argument must be an object."
      ) : invariant(obj instanceof Object && !Array.isArray(obj));
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  }
});

// node_modules/react-component/lib/EventConstants.js
var require_EventConstants = __commonJS({
  "node_modules/react-component/lib/EventConstants.js"(exports, module) {
    "use strict";
    var keyMirror = require_keyMirror();
    var PropagationPhases = keyMirror({ bubbled: null, captured: null });
    var topLevelTypes = keyMirror({
      topBlur: null,
      topChange: null,
      topClick: null,
      topCompositionEnd: null,
      topCompositionStart: null,
      topCompositionUpdate: null,
      topContextMenu: null,
      topCopy: null,
      topCut: null,
      topDoubleClick: null,
      topDrag: null,
      topDragEnd: null,
      topDragEnter: null,
      topDragExit: null,
      topDragLeave: null,
      topDragOver: null,
      topDragStart: null,
      topDrop: null,
      topError: null,
      topFocus: null,
      topInput: null,
      topKeyDown: null,
      topKeyPress: null,
      topKeyUp: null,
      topLoad: null,
      topMouseDown: null,
      topMouseMove: null,
      topMouseOut: null,
      topMouseOver: null,
      topMouseUp: null,
      topPaste: null,
      topReset: null,
      topScroll: null,
      topSelectionChange: null,
      topSubmit: null,
      topTouchCancel: null,
      topTouchEnd: null,
      topTouchMove: null,
      topTouchStart: null,
      topWheel: null
    });
    var EventConstants = {
      topLevelTypes,
      PropagationPhases
    };
    module.exports = EventConstants;
  }
});

// node_modules/react-component/lib/EventPluginUtils.js
var require_EventPluginUtils = __commonJS({
  "node_modules/react-component/lib/EventPluginUtils.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var invariant = require_invariant();
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if (require_React().__DEV__ === true) {
          require_React().__DEV__ === true ? invariant(
            InjectedMount && InjectedMount.getNode,
            "EventPluginUtils.injection.injectMount(...): Injected Mount module is missing getNode."
          ) : invariant(InjectedMount && InjectedMount.getNode);
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if (require_React().__DEV__ === true) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        require_React().__DEV__ === true ? invariant(
          idsIsArr === listenersIsArr && IDsLen === listenersLen,
          "EventPluginUtils: Invalid `event`."
        ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen);
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (require_React().__DEV__ === true) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, executeDispatch2) {
      forEachEventDispatch(event, executeDispatch2);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (require_React().__DEV__ === true) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDirectDispatch(event) {
      if (require_React().__DEV__ === true) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      require_React().__DEV__ === true ? invariant(
        !Array.isArray(dispatchListener),
        "executeDirectDispatch(...): Invalid `event`."
      ) : invariant(!Array.isArray(dispatchListener));
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish,
      isMoveish,
      isStartish,
      executeDirectDispatch,
      executeDispatch,
      executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue,
      hasDispatches,
      injection,
      useTouchEvents: false
    };
    module.exports = EventPluginUtils;
  }
});

// node_modules/react-component/lib/PooledClass.js
var require_PooledClass = __commonJS({
  "node_modules/react-component/lib/PooledClass.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      require_React().__DEV__ === true ? invariant(
        instance instanceof Klass,
        "Trying to release an instance into a pool of a different type."
      ) : invariant(instance instanceof Klass);
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo,
      oneArgumentPooler,
      twoArgumentPooler,
      threeArgumentPooler,
      fiveArgumentPooler
    };
    module.exports = PooledClass;
  }
});

// node_modules/react-component/lib/ReactRootIndex.js
var require_ReactRootIndex = __commonJS({
  "node_modules/react-component/lib/ReactRootIndex.js"(exports, module) {
    "use strict";
    var ReactRootIndexInjection = {
      /**
       * @param {function} _createReactRootIndex
       */
      injectCreateReactRootIndex: function(_createReactRootIndex) {
        ReactRootIndex.createReactRootIndex = _createReactRootIndex;
      }
    };
    var ReactRootIndex = {
      createReactRootIndex: null,
      injection: ReactRootIndexInjection
    };
    module.exports = ReactRootIndex;
  }
});

// node_modules/react-component/lib/ReactInstanceHandles.js
var require_ReactInstanceHandles = __commonJS({
  "node_modules/react-component/lib/ReactInstanceHandles.js"(exports, module) {
    "use strict";
    var ReactRootIndex = require_ReactRootIndex();
    var invariant = require_invariant();
    var SEPARATOR = ".";
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === "" || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : "";
    }
    function getNextDescendantID(ancestorID, destinationID) {
      require_React().__DEV__ === true ? invariant(
        isValidID(ancestorID) && isValidID(destinationID),
        "getNextDescendantID(%s, %s): Received an invalid React DOM ID.",
        ancestorID,
        destinationID
      ) : invariant(isValidID(ancestorID) && isValidID(destinationID));
      require_React().__DEV__ === true ? invariant(
        isAncestorIDOf(ancestorID, destinationID),
        "getNextDescendantID(...): React has made an invalid assumption about the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.",
        ancestorID,
        destinationID
      ) : invariant(isAncestorIDOf(ancestorID, destinationID));
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      for (var i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return "";
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      require_React().__DEV__ === true ? invariant(
        isValidID(longestCommonID),
        "getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s",
        oneID,
        twoID,
        longestCommonID
      ) : invariant(isValidID(longestCommonID));
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || "";
      stop = stop || "";
      require_React().__DEV__ === true ? invariant(
        start !== stop,
        "traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.",
        start
      ) : invariant(start !== stop);
      var traverseUp = isAncestorIDOf(stop, start);
      require_React().__DEV__ === true ? invariant(
        traverseUp || isAncestorIDOf(start, stop),
        "traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do not have a parent path.",
        start,
        stop
      ) : invariant(traverseUp || isAncestorIDOf(start, stop));
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        require_React().__DEV__ === true ? invariant(
          depth++ < MAX_TREE_DEPTH,
          "traverseParentPath(%s, %s, ...): Detected an infinite loop while traversing the React DOM ID tree. This may be due to malformed IDs: %s",
          start,
          stop
        ) : invariant(depth++ < MAX_TREE_DEPTH);
      }
    }
    var ReactInstanceHandles = {
      /**
       * Constructs a React root ID
       * @return {string} A React root ID.
       */
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      /**
       * Constructs a React ID by joining a root ID with a name.
       *
       * @param {string} rootID Root ID of a parent component.
       * @param {string} name A component's name (as flattened children).
       * @return {string} A React ID.
       * @internal
       */
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      /**
       * Gets the DOM ID of the React component that is the root of the tree that
       * contains the React component with the supplied DOM ID.
       *
       * @param {string} id DOM ID of a React component.
       * @return {?string} DOM ID of the React component that is the root.
       * @internal
       */
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      /**
       * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
       * should would receive a `mouseEnter` or `mouseLeave` event.
       *
       * NOTE: Does not invoke the callback on the nearest common ancestor because
       * nothing "entered" or "left" that element.
       *
       * @param {string} leaveID ID being left.
       * @param {string} enterID ID being entered.
       * @param {function} cb Callback to invoke on each entered/left ID.
       * @param {*} upArg Argument to invoke the callback with on left IDs.
       * @param {*} downArg Argument to invoke the callback with on entered IDs.
       * @internal
       */
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      /**
       * Simulates the traversal of a two-phase, capture/bubble event dispatch.
       *
       * NOTE: This traversal happens on IDs without touching the DOM.
       *
       * @param {string} targetID ID of the target node.
       * @param {function} cb Callback to invoke.
       * @param {*} arg Argument to invoke the callback with.
       * @internal
       */
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath("", targetID, cb, arg, true, false);
          traverseParentPath(targetID, "", cb, arg, false, true);
        }
      },
      /**
       * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
       * example, passing `.0.$row-0.1` would result in `cb` getting called
       * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
       *
       * NOTE: This traversal happens on IDs without touching the DOM.
       *
       * @param {string} targetID ID of the target node.
       * @param {function} cb Callback to invoke.
       * @param {*} arg Argument to invoke the callback with.
       * @internal
       */
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath("", targetID, cb, arg, true, false);
      },
      /**
       * Exposed for unit testing.
       * @private
       */
      _getFirstCommonAncestorID: getFirstCommonAncestorID,
      /**
       * Exposed for unit testing.
       * @private
       */
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf,
      SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  }
});

// node_modules/react-component/lib/EventListener.js
var require_EventListener = __commonJS({
  "node_modules/react-component/lib/EventListener.js"(exports, module) {
    var emptyFunction = require_emptyFunction();
    var EventListener = {
      /**
       * Listen to DOM events during the bubble phase.
       *
       * @param {DOMEventTarget} target DOM element to register listener on.
       * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
       * @param {function} callback Callback function.
       * @return {object} Object with a `remove` method.
       */
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {
            remove: function() {
              target.removeEventListener(eventType, callback, false);
            }
          };
        } else if (target.attachEvent) {
          target.attachEvent("on" + eventType, callback);
          return {
            remove: function() {
              target.detachEvent(eventType, callback);
            }
          };
        }
      },
      /**
       * Listen to DOM events during the capture phase.
       *
       * @param {DOMEventTarget} target DOM element to register listener on.
       * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
       * @param {function} callback Callback function.
       * @return {object} Object with a `remove` method.
       */
      capture: function(target, eventType, callback) {
        if (!target.addEventListener) {
          if (require_React().__DEV__ === true) {
            console.error(
              "Attempted to listen to events during the capture phase on a browser that does not support the capture phase. Your application will not receive some events."
            );
          }
          return {
            remove: emptyFunction
          };
        } else {
          target.addEventListener(eventType, callback, true);
          return {
            remove: function() {
              target.removeEventListener(eventType, callback, true);
            }
          };
        }
      }
    };
    module.exports = EventListener;
  }
});

// node_modules/react-component/lib/EventPluginRegistry.js
var require_EventPluginRegistry = __commonJS({
  "node_modules/react-component/lib/EventPluginRegistry.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        require_React().__DEV__ === true ? invariant(
          pluginIndex > -1,
          "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.",
          pluginName
        ) : invariant(pluginIndex > -1);
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        require_React().__DEV__ === true ? invariant(
          PluginModule.extractEvents,
          "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.",
          pluginName
        ) : invariant(PluginModule.extractEvents);
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          require_React().__DEV__ === true ? invariant(
            publishEventForPlugin(
              publishedEvents[eventName],
              PluginModule,
              eventName
            ),
            "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.",
            eventName,
            pluginName
          ) : invariant(publishEventForPlugin(
            publishedEvents[eventName],
            PluginModule,
            eventName
          ));
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      require_React().__DEV__ === true ? invariant(
        !EventPluginRegistry.eventNameDispatchConfigs[eventName],
        "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.",
        eventName
      ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs[eventName]);
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(
              phasedRegistrationName,
              PluginModule,
              eventName
            );
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(
          dispatchConfig.registrationName,
          PluginModule,
          eventName
        );
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      require_React().__DEV__ === true ? invariant(
        !EventPluginRegistry.registrationNameModules[registrationName],
        "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.",
        registrationName
      ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]);
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      /**
       * Ordered list of injected plugins.
       */
      plugins: [],
      /**
       * Mapping from event name to dispatch config
       */
      eventNameDispatchConfigs: {},
      /**
       * Mapping from registration name to plugin module
       */
      registrationNameModules: {},
      /**
       * Mapping from registration name to event name
       */
      registrationNameDependencies: {},
      /**
       * Injects an ordering of plugins (by plugin name). This allows the ordering
       * to be decoupled from injection of the actual plugins so that ordering is
       * always deterministic regardless of packaging, on-the-fly injection, etc.
       *
       * @param {array} InjectedEventPluginOrder
       * @internal
       * @see {EventPluginHub.injection.injectEventPluginOrder}
       */
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        require_React().__DEV__ === true ? invariant(
          !EventPluginOrder,
          "EventPluginRegistry: Cannot inject event plugin ordering more than once."
        ) : invariant(!EventPluginOrder);
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      /**
       * Injects plugins to be used by `EventPluginHub`. The plugin names must be
       * in the ordering injected by `injectEventPluginOrder`.
       *
       * Plugins can be injected as part of page initialization or on-the-fly.
       *
       * @param {object} injectedNamesToPlugins Map from names to plugin modules.
       * @internal
       * @see {EventPluginHub.injection.injectEventPluginsByName}
       */
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (namesToPlugins[pluginName] !== PluginModule) {
            require_React().__DEV__ === true ? invariant(
              !namesToPlugins[pluginName],
              "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.",
              pluginName
            ) : invariant(!namesToPlugins[pluginName]);
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      /**
       * Looks up the plugin for the supplied event.
       *
       * @param {object} event A synthetic event.
       * @return {?object} The plugin that created the supplied event.
       * @internal
       */
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      /**
       * Exposed for unit testing.
       * @private
       */
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  }
});

// node_modules/react-component/lib/ExecutionEnvironment.js
var require_ExecutionEnvironment = __commonJS({
  "node_modules/react-component/lib/ExecutionEnvironment.js"(exports, module) {
    "use strict";
    var canUseDOM = typeof window !== "undefined";
    var ExecutionEnvironment = {
      canUseDOM,
      canUseWorkers: typeof Worker !== "undefined",
      canUseEventListeners: canUseDOM && (window.addEventListener || window.attachEvent),
      isInWorker: !canUseDOM
      // For now, this is true - might change in the future.
    };
    module.exports = ExecutionEnvironment;
  }
});

// node_modules/react-component/lib/accumulate.js
var require_accumulate = __commonJS({
  "node_modules/react-component/lib/accumulate.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    function accumulate(current, next) {
      require_React().__DEV__ === true ? invariant(
        next != null,
        "accumulate(...): Accumulated items must be not be null or undefined."
      ) : invariant(next != null);
      if (current == null) {
        return next;
      } else {
        var currentIsArray = Array.isArray(current);
        var nextIsArray = Array.isArray(next);
        if (currentIsArray) {
          return current.concat(next);
        } else {
          if (nextIsArray) {
            return [current].concat(next);
          } else {
            return [current, next];
          }
        }
      }
    }
    module.exports = accumulate;
  }
});

// node_modules/react-component/lib/forEachAccumulated.js
var require_forEachAccumulated = __commonJS({
  "node_modules/react-component/lib/forEachAccumulated.js"(exports, module) {
    "use strict";
    var forEachAccumulated = function(arr, cb, scope) {
      if (Array.isArray(arr)) {
        arr.forEach(cb, scope);
      } else if (arr) {
        cb.call(scope, arr);
      }
    };
    module.exports = forEachAccumulated;
  }
});

// node_modules/react-component/lib/isEventSupported.js
var require_isEventSupported = __commonJS({
  "node_modules/react-component/lib/isEventSupported.js"(exports, module) {
    "use strict";
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var useHasFeature;
    if (ExecutionEnvironment.canUseDOM) {
      useHasFeature = document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
      document.implementation.hasFeature("", "") !== true;
    }
    function isEventSupported(eventNameSuffix, capture) {
      if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
        return false;
      }
      var eventName = "on" + eventNameSuffix;
      var isSupported = eventName in document;
      if (!isSupported) {
        var element = document.createElement("div");
        element.setAttribute(eventName, "return;");
        isSupported = typeof element[eventName] === "function";
      }
      if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
        isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
      }
      return isSupported;
    }
    module.exports = isEventSupported;
  }
});

// node_modules/react-component/lib/monitorCodeUse.js
var require_monitorCodeUse = __commonJS({
  "node_modules/react-component/lib/monitorCodeUse.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    function monitorCodeUse(eventName, data) {
      require_React().__DEV__ === true ? invariant(
        eventName && !/[^a-z0-9_]/.test(eventName),
        "You must provide an eventName using only the characters [a-z0-9_]"
      ) : invariant(eventName && !/[^a-z0-9_]/.test(eventName));
    }
    module.exports = monitorCodeUse;
  }
});

// node_modules/react-component/lib/EventPluginHub.js
var require_EventPluginHub = __commonJS({
  "node_modules/react-component/lib/EventPluginHub.js"(exports, module) {
    "use strict";
    var EventPluginRegistry = require_EventPluginRegistry();
    var EventPluginUtils = require_EventPluginUtils();
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var accumulate = require_accumulate();
    var forEachAccumulated = require_forEachAccumulated();
    var invariant = require_invariant();
    var isEventSupported = require_isEventSupported();
    var monitorCodeUse = require_monitorCodeUse();
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var invalid = !InstanceHandle || !InstanceHandle.traverseTwoPhase || !InstanceHandle.traverseEnterLeave;
      if (invalid) {
        throw new Error("InstanceHandle not injected before use!");
      }
    }
    var EventPluginHub = {
      /**
       * Methods for injecting dependencies.
       */
      injection: {
        /**
         * @param {object} InjectedMount
         * @public
         */
        injectMount: EventPluginUtils.injection.injectMount,
        /**
         * @param {object} InjectedInstanceHandle
         * @public
         */
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if (require_React().__DEV__ === true) {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if (require_React().__DEV__ === true) {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        /**
         * @param {array} InjectedEventPluginOrder
         * @public
         */
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        /**
         * @param {object} injectedNamesToPlugins Map from names to plugin modules.
         */
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      /**
       * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
       *
       * @param {string} id ID of the DOM element.
       * @param {string} registrationName Name of listener (e.g. `onClick`).
       * @param {?function} listener The callback to store.
       */
      putListener: function(id, registrationName, listener) {
        require_React().__DEV__ === true ? invariant(
          ExecutionEnvironment.canUseDOM,
          "Cannot call putListener() in a non-DOM environment."
        ) : invariant(ExecutionEnvironment.canUseDOM);
        require_React().__DEV__ === true ? invariant(
          !listener || typeof listener === "function",
          "Expected %s listener to be a function, instead got type %s",
          registrationName,
          typeof listener
        ) : invariant(!listener || typeof listener === "function");
        if (require_React().__DEV__ === true) {
          if (registrationName === "onScroll" && !isEventSupported("scroll", true)) {
            monitorCodeUse("react_no_scroll_event");
            console.warn("This browser doesn't support the `onScroll` event");
          }
        }
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
      },
      /**
       * @param {string} id ID of the DOM element.
       * @param {string} registrationName Name of listener (e.g. `onClick`).
       * @return {?function} The stored callback.
       */
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      /**
       * Deletes a listener from the registration bank.
       *
       * @param {string} id ID of the DOM element.
       * @param {string} registrationName Name of listener (e.g. `onClick`).
       */
      deleteListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      /**
       * Deletes all listeners for the DOM element with the supplied ID.
       *
       * @param {string} id ID of the DOM element.
       */
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          delete listenerBank[registrationName][id];
        }
      },
      /**
       * Allows registered plugins an opportunity to extract events from top-level
       * native browser events.
       *
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @internal
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0, l = plugins.length; i < l; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(
              topLevelType,
              topLevelTarget,
              topLevelTargetID,
              nativeEvent
            );
            if (extractedEvents) {
              events = accumulate(events, extractedEvents);
            }
          }
        }
        return events;
      },
      /**
       * Enqueues a synthetic event that should be dispatched when
       * `processEventQueue` is invoked.
       *
       * @param {*} events An accumulation of synthetic events.
       * @internal
       */
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulate(eventQueue, events);
        }
      },
      /**
       * Dispatches all synthetic events on the event queue.
       *
       * @internal
       */
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        require_React().__DEV__ === true ? invariant(
          !eventQueue,
          "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
        ) : invariant(!eventQueue);
      },
      /**
       * These are needed for tests only. Do not use!
       */
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  }
});

// node_modules/react-component/lib/ReactPerf.js
var require_ReactPerf = __commonJS({
  "node_modules/react-component/lib/ReactPerf.js"(exports, module) {
    "use strict";
    var ReactPerf = {
      /**
       * Boolean to enable/disable measurement. Set to false by default to prevent
       * accidental logging and perf loss.
       */
      enableMeasure: false,
      /**
       * Holds onto the measure function in use. By default, don't measure
       * anything, but we'll override this if we inject a measure function.
       */
      storedMeasure: _noMeasure,
      /**
       * Use this to wrap methods you want to measure. Zero overhead in production.
       *
       * @param {string} objName
       * @param {string} fnName
       * @param {function} func
       * @return {function}
       */
      measure: function(objName, fnName, func) {
        if (require_React().__DEV__ === true) {
          var measuredFunc = null;
          return function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
        }
        return func;
      },
      injection: {
        /**
         * @param {function} measure
         */
        injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }
      }
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  }
});

// node_modules/react-component/lib/ReactUpdates.js
var require_ReactUpdates = __commonJS({
  "node_modules/react-component/lib/ReactUpdates.js"(exports, module) {
    "use strict";
    var ReactPerf = require_ReactPerf();
    var invariant = require_invariant();
    var dirtyComponents = [];
    var batchingStrategy = null;
    function ensureBatchingStrategy() {
      require_React().__DEV__ === true ? invariant(batchingStrategy, "ReactUpdates: must inject a batching strategy") : invariant(batchingStrategy);
    }
    function batchedUpdates(callback, param) {
      ensureBatchingStrategy();
      batchingStrategy.batchedUpdates(callback, param);
    }
    function mountDepthComparator(c1, c2) {
      return c1._mountDepth - c2._mountDepth;
    }
    function runBatchedUpdates() {
      dirtyComponents.sort(mountDepthComparator);
      for (var i = 0; i < dirtyComponents.length; i++) {
        var component = dirtyComponents[i];
        if (component.isMounted()) {
          var callbacks = component._pendingCallbacks;
          component._pendingCallbacks = null;
          component.performUpdateIfNecessary();
          if (callbacks) {
            for (var j = 0; j < callbacks.length; j++) {
              callbacks[j].call(component);
            }
          }
        }
      }
    }
    function clearDirtyComponents() {
      dirtyComponents.length = 0;
    }
    var flushBatchedUpdates = ReactPerf.measure(
      "ReactUpdates",
      "flushBatchedUpdates",
      function() {
        try {
          runBatchedUpdates();
        } finally {
          clearDirtyComponents();
        }
      }
    );
    function enqueueUpdate(component, callback) {
      require_React().__DEV__ === true ? invariant(
        !callback || typeof callback === "function",
        "enqueueUpdate(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable."
      ) : invariant(!callback || typeof callback === "function");
      ensureBatchingStrategy();
      if (!batchingStrategy.isBatchingUpdates) {
        component.performUpdateIfNecessary();
        callback && callback.call(component);
        return;
      }
      dirtyComponents.push(component);
      if (callback) {
        if (component._pendingCallbacks) {
          component._pendingCallbacks.push(callback);
        } else {
          component._pendingCallbacks = [callback];
        }
      }
    }
    var ReactUpdatesInjection = {
      injectBatchingStrategy: function(_batchingStrategy) {
        require_React().__DEV__ === true ? invariant(
          _batchingStrategy,
          "ReactUpdates: must provide a batching strategy"
        ) : invariant(_batchingStrategy);
        require_React().__DEV__ === true ? invariant(
          typeof _batchingStrategy.batchedUpdates === "function",
          "ReactUpdates: must provide a batchedUpdates() function"
        ) : invariant(typeof _batchingStrategy.batchedUpdates === "function");
        require_React().__DEV__ === true ? invariant(
          typeof _batchingStrategy.isBatchingUpdates === "boolean",
          "ReactUpdates: must provide an isBatchingUpdates boolean attribute"
        ) : invariant(typeof _batchingStrategy.isBatchingUpdates === "boolean");
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      batchedUpdates,
      enqueueUpdate,
      flushBatchedUpdates,
      injection: ReactUpdatesInjection
    };
    module.exports = ReactUpdates;
  }
});

// node_modules/react-component/lib/ReactEventEmitterMixin.js
var require_ReactEventEmitterMixin = __commonJS({
  "node_modules/react-component/lib/ReactEventEmitterMixin.js"(exports, module) {
    "use strict";
    var EventPluginHub = require_EventPluginHub();
    var ReactUpdates = require_ReactUpdates();
    function runEventQueueInBatch(events) {
      EventPluginHub.enqueueEvents(events);
      EventPluginHub.processEventQueue();
    }
    var ReactEventEmitterMixin = {
      /**
       * Streams a fired top-level event to `EventPluginHub` where plugins have the
       * opportunity to create `ReactEvent`s to be dispatched.
       *
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {object} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native environment event.
       */
      handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events = EventPluginHub.extractEvents(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
        ReactUpdates.batchedUpdates(runEventQueueInBatch, events);
      }
    };
    module.exports = ReactEventEmitterMixin;
  }
});

// node_modules/react-component/lib/getUnboundedScrollPosition.js
var require_getUnboundedScrollPosition = __commonJS({
  "node_modules/react-component/lib/getUnboundedScrollPosition.js"(exports, module) {
    "use strict";
    function getUnboundedScrollPosition(scrollable) {
      if (scrollable === window) {
        return {
          x: window.pageXOffset || document.documentElement.scrollLeft,
          y: window.pageYOffset || document.documentElement.scrollTop
        };
      }
      return {
        x: scrollable.scrollLeft,
        y: scrollable.scrollTop
      };
    }
    module.exports = getUnboundedScrollPosition;
  }
});

// node_modules/react-component/lib/ViewportMetrics.js
var require_ViewportMetrics = __commonJS({
  "node_modules/react-component/lib/ViewportMetrics.js"(exports, module) {
    "use strict";
    var getUnboundedScrollPosition = require_getUnboundedScrollPosition();
    var ViewportMetrics = {
      currentScrollLeft: 0,
      currentScrollTop: 0,
      refreshScrollValues: function() {
        var scrollPosition = getUnboundedScrollPosition(window);
        ViewportMetrics.currentScrollLeft = scrollPosition.x;
        ViewportMetrics.currentScrollTop = scrollPosition.y;
      }
    };
    module.exports = ViewportMetrics;
  }
});

// node_modules/react-component/lib/ReactEventEmitter.js
var require_ReactEventEmitter = __commonJS({
  "node_modules/react-component/lib/ReactEventEmitter.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventListener = require_EventListener();
    var EventPluginHub = require_EventPluginHub();
    var EventPluginRegistry = require_EventPluginRegistry();
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var ReactEventEmitterMixin = require_ReactEventEmitterMixin();
    var ViewportMetrics = require_ViewportMetrics();
    var invariant = require_invariant();
    var isEventSupported = require_isEventSupported();
    var merge = require_merge();
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topBlur: "blur",
      topChange: "change",
      topClick: "click",
      topCompositionEnd: "compositionend",
      topCompositionStart: "compositionstart",
      topCompositionUpdate: "compositionupdate",
      topContextMenu: "contextmenu",
      topCopy: "copy",
      topCut: "cut",
      topDoubleClick: "dblclick",
      topDrag: "drag",
      topDragEnd: "dragend",
      topDragEnter: "dragenter",
      topDragExit: "dragexit",
      topDragLeave: "dragleave",
      topDragOver: "dragover",
      topDragStart: "dragstart",
      topDrop: "drop",
      topFocus: "focus",
      topInput: "input",
      topKeyDown: "keydown",
      topKeyPress: "keypress",
      topKeyUp: "keyup",
      topMouseDown: "mousedown",
      topMouseMove: "mousemove",
      topMouseOut: "mouseout",
      topMouseOver: "mouseover",
      topMouseUp: "mouseup",
      topPaste: "paste",
      topScroll: "scroll",
      topSelectionChange: "selectionchange",
      topTouchCancel: "touchcancel",
      topTouchEnd: "touchend",
      topTouchMove: "touchmove",
      topTouchStart: "touchstart",
      topWheel: "wheel"
    };
    var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (mountAt[topListenersIDKey] == null) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    function trapBubbledEvent(topLevelType, handlerBaseName, element) {
      EventListener.listen(
        element,
        handlerBaseName,
        ReactEventEmitter.TopLevelCallbackCreator.createTopLevelCallback(
          topLevelType
        )
      );
    }
    function trapCapturedEvent(topLevelType, handlerBaseName, element) {
      EventListener.capture(
        element,
        handlerBaseName,
        ReactEventEmitter.TopLevelCallbackCreator.createTopLevelCallback(
          topLevelType
        )
      );
    }
    var ReactEventEmitter = merge(ReactEventEmitterMixin, {
      /**
       * React references `ReactEventTopLevelCallback` using this property in order
       * to allow dependency injection.
       */
      TopLevelCallbackCreator: null,
      injection: {
        /**
         * @param {function} TopLevelCallbackCreator
         */
        injectTopLevelCallbackCreator: function(TopLevelCallbackCreator) {
          ReactEventEmitter.TopLevelCallbackCreator = TopLevelCallbackCreator;
        }
      },
      /**
       * Sets whether or not any created callbacks should be enabled.
       *
       * @param {boolean} enabled True if callbacks should be enabled.
       */
      setEnabled: function(enabled) {
        require_React().__DEV__ === true ? invariant(
          ExecutionEnvironment.canUseDOM,
          "setEnabled(...): Cannot toggle event listening in a Worker thread. This is likely a bug in the framework. Please report immediately."
        ) : invariant(ExecutionEnvironment.canUseDOM);
        if (ReactEventEmitter.TopLevelCallbackCreator) {
          ReactEventEmitter.TopLevelCallbackCreator.setEnabled(enabled);
        }
      },
      /**
       * @return {boolean} True if callbacks are enabled.
       */
      isEnabled: function() {
        return !!(ReactEventEmitter.TopLevelCallbackCreator && ReactEventEmitter.TopLevelCallbackCreator.isEnabled());
      },
      /**
       * We listen for bubbled touch events on the document object.
       *
       * Firefox v8.01 (and possibly others) exhibited strange behavior when
       * mounting `onmousemove` events at some node that was not the document
       * element. The symptoms were that if your mouse is not moving over something
       * contained within that mount point (for example on the background) the
       * top-level listeners for `onmousemove` won't be called. However, if you
       * register the `mousemove` on the document object, then it will of course
       * catch all `mousemove`s. This along with iOS quirks, justifies restricting
       * top-level listeners to the document object only, at least for these
       * movement types of events and possibly all events.
       *
       * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
       *
       * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
       * they bubble to document.
       *
       * @param {string} registrationName Name of listener (e.g. `onClick`).
       * @param {DOMDocument} contentDocument Document which owns the container
       */
      listenTo: function(registrationName, contentDocument) {
        var mountAt = contentDocument;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0, l = dependencies.length; i < l; i++) {
          var dependency = dependencies[i];
          if (!isListening[dependency]) {
            var topLevelType = topLevelTypes[dependency];
            if (topLevelType === topLevelTypes.topWheel) {
              if (isEventSupported("wheel")) {
                trapBubbledEvent(topLevelTypes.topWheel, "wheel", mountAt);
              } else if (isEventSupported("mousewheel")) {
                trapBubbledEvent(topLevelTypes.topWheel, "mousewheel", mountAt);
              } else {
                trapBubbledEvent(
                  topLevelTypes.topWheel,
                  "DOMMouseScroll",
                  mountAt
                );
              }
            } else if (topLevelType === topLevelTypes.topScroll) {
              if (isEventSupported("scroll", true)) {
                trapCapturedEvent(topLevelTypes.topScroll, "scroll", mountAt);
              } else {
                trapBubbledEvent(topLevelTypes.topScroll, "scroll", window);
              }
            } else if (topLevelType === topLevelTypes.topFocus || topLevelType === topLevelTypes.topBlur) {
              if (isEventSupported("focus", true)) {
                trapCapturedEvent(topLevelTypes.topFocus, "focus", mountAt);
                trapCapturedEvent(topLevelTypes.topBlur, "blur", mountAt);
              } else if (isEventSupported("focusin")) {
                trapBubbledEvent(topLevelTypes.topFocus, "focusin", mountAt);
                trapBubbledEvent(topLevelTypes.topBlur, "focusout", mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping[dependency]) {
              trapBubbledEvent(topLevelType, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      /**
       * Listens to window scroll and resize events. We cache scroll values so that
       * application code can access them without triggering reflows.
       *
       * NOTE: Scroll events do not bubble.
       *
       * @see http://www.quirksmode.org/dom/events/scroll.html
       */
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          EventListener.listen(window, "scroll", refresh);
          EventListener.listen(window, "resize", refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners,
      trapBubbledEvent,
      trapCapturedEvent
    });
    module.exports = ReactEventEmitter;
  }
});

// node_modules/react-component/lib/isNode.js
var require_isNode = __commonJS({
  "node_modules/react-component/lib/isNode.js"(exports, module) {
    function isNode(object) {
      return !!(object && (typeof Node === "function" ? object instanceof Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
    }
    module.exports = isNode;
  }
});

// node_modules/react-component/lib/isTextNode.js
var require_isTextNode = __commonJS({
  "node_modules/react-component/lib/isTextNode.js"(exports, module) {
    var isNode = require_isNode();
    function isTextNode(object) {
      return isNode(object) && object.nodeType == 3;
    }
    module.exports = isTextNode;
  }
});

// node_modules/react-component/lib/containsNode.js
var require_containsNode = __commonJS({
  "node_modules/react-component/lib/containsNode.js"(exports, module) {
    var isTextNode = require_isTextNode();
    function containsNode(outerNode, innerNode) {
      if (!outerNode || !innerNode) {
        return false;
      } else if (outerNode === innerNode) {
        return true;
      } else if (isTextNode(outerNode)) {
        return false;
      } else if (isTextNode(innerNode)) {
        return containsNode(outerNode, innerNode.parentNode);
      } else if (outerNode.contains) {
        return outerNode.contains(innerNode);
      } else if (outerNode.compareDocumentPosition) {
        return !!(outerNode.compareDocumentPosition(innerNode) & 16);
      } else {
        return false;
      }
    }
    module.exports = containsNode;
  }
});

// node_modules/react-component/lib/getReactRootElementInContainer.js
var require_getReactRootElementInContainer = __commonJS({
  "node_modules/react-component/lib/getReactRootElementInContainer.js"(exports, module) {
    "use strict";
    var DOC_NODE_TYPE = 9;
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    module.exports = getReactRootElementInContainer;
  }
});

// node_modules/react-component/lib/instantiateReactComponent.js
var require_instantiateReactComponent = __commonJS({
  "node_modules/react-component/lib/instantiateReactComponent.js"(exports, module) {
    "use strict";
    var warning = require_warning();
    function isValidComponentDescriptor(descriptor) {
      return typeof descriptor.constructor === "function" && typeof descriptor.constructor.prototype.construct === "function" && typeof descriptor.constructor.prototype.mountComponent === "function" && typeof descriptor.constructor.prototype.receiveComponent === "function";
    }
    function instantiateReactComponent(descriptor) {
      if (require_React().__DEV__ === true) {
        require_React().__DEV__ === true ? warning(
          isValidComponentDescriptor(descriptor),
          "Only React Components are valid for mounting."
        ) : null;
        var instance = descriptor.__realComponentInstance || descriptor;
        instance._descriptor = descriptor;
        return instance;
      }
      descriptor._descriptor = descriptor;
      return descriptor;
    }
    module.exports = instantiateReactComponent;
  }
});

// node_modules/react-component/lib/shouldUpdateReactComponent.js
var require_shouldUpdateReactComponent = __commonJS({
  "node_modules/react-component/lib/shouldUpdateReactComponent.js"(exports, module) {
    "use strict";
    function shouldUpdateReactComponent(prevComponentInstance, nextDescriptor) {
      if (prevComponentInstance && nextDescriptor && prevComponentInstance.constructor === nextDescriptor.constructor && (prevComponentInstance.props && prevComponentInstance.props.key) === (nextDescriptor.props && nextDescriptor.props.key)) {
        if (prevComponentInstance._owner === nextDescriptor._owner) {
          return true;
        } else {
          if (require_React().__DEV__ === true) {
            if (prevComponentInstance.state) {
              console.warn(
                "A recent change to React has been found to impact your code. A mounted component will now be unmounted and replaced by a component (of the same class) if their owners are different. Previously, ownership was not considered when updating.",
                prevComponentInstance,
                nextDescriptor
              );
            }
          }
        }
      }
      return false;
    }
    module.exports = shouldUpdateReactComponent;
  }
});

// node_modules/react-component/lib/ReactMount.js
var require_ReactMount = __commonJS({
  "node_modules/react-component/lib/ReactMount.js"(exports, module) {
    "use strict";
    var DOMProperty = require_DOMProperty();
    var ReactEventEmitter = require_ReactEventEmitter();
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactPerf = require_ReactPerf();
    var containsNode = require_containsNode();
    var getReactRootElementInContainer = require_getReactRootElementInContainer();
    var instantiateReactComponent = require_instantiateReactComponent();
    var invariant = require_invariant();
    var shouldUpdateReactComponent = require_shouldUpdateReactComponent();
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if (require_React().__DEV__ === true) {
      rootElementsByReactRootID = {};
    }
    var rootElementsByReactRootID;
    var findComponentRootReusableArray = [];
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            require_React().__DEV__ === true ? invariant(
              !isValid(cached, id),
              "ReactMount: Two valid but unequal nodes with the same `%s`: %s",
              ATTR_NAME,
              id
            ) : invariant(!isValid(cached, id));
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || "";
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        require_React().__DEV__ === true ? invariant(
          internalGetID(node) === id,
          "ReactMount: Unexpected modification of `%s`",
          ATTR_NAME
        ) : invariant(internalGetID(node) === id);
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(
        targetID,
        findDeepestCachedAncestorImpl
      );
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    var ReactMount = {
      /** Time spent generating markup. */
      totalInstantiationTime: 0,
      /** Time spent inserting markup into the DOM. */
      totalInjectionTime: 0,
      /** Whether support for touch events should be initialized. */
      useTouchEvents: false,
      /** Exposed for debugging purposes **/
      _instancesByReactRootID: instancesByReactRootID,
      /**
       * This is a hook provided to support rendering React components while
       * ensuring that the apparent scroll position of its `container` does not
       * change.
       *
       * @param {DOMElement} container The `container` being rendered into.
       * @param {function} renderCallback This must be called once to do the render.
       */
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      /**
       * Take a component that's already mounted into the DOM and replace its props
       * @param {ReactComponent} prevComponent component instance already in the DOM
       * @param {ReactComponent} nextComponent component instance to render
       * @param {DOMElement} container container to render into
       * @param {?function} callback function triggered on completion
       */
      _updateRootComponent: function(prevComponent, nextComponent, container, callback) {
        var nextProps = nextComponent.props;
        ReactMount.scrollMonitor(container, function() {
          prevComponent.replaceProps(nextProps, callback);
        });
        if (require_React().__DEV__ === true) {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      /**
       * Register a component into the instance map and starts scroll value
       * monitoring
       * @param {ReactComponent} nextComponent component instance to render
       * @param {DOMElement} container container to render into
       * @return {string} reactRoot ID prefix
       */
      _registerComponent: function(nextComponent, container) {
        require_React().__DEV__ === true ? invariant(
          container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE),
          "_registerComponent(...): Target container is not a DOM element."
        ) : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
        ReactEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      /**
       * Render a new component into the DOM.
       * @param {ReactComponent} nextComponent component instance to render
       * @param {DOMElement} container container to render into
       * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
       * @return {ReactComponent} nextComponent
       */
      _renderNewRootComponent: ReactPerf.measure(
        "ReactMount",
        "_renderNewRootComponent",
        function(nextComponent, container, shouldReuseMarkup) {
          var componentInstance = instantiateReactComponent(nextComponent);
          var reactRootID = ReactMount._registerComponent(
            componentInstance,
            container
          );
          componentInstance.mountComponentIntoNode(
            reactRootID,
            container,
            shouldReuseMarkup
          );
          if (require_React().__DEV__ === true) {
            rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
          }
          return componentInstance;
        }
      ),
      /**
       * Renders a React component into the DOM in the supplied `container`.
       *
       * If the React component was previously rendered into `container`, this will
       * perform an update on it and only mutate the DOM as necessary to reflect the
       * latest React component.
       *
       * @param {ReactComponent} nextComponent Component instance to render.
       * @param {DOMElement} container DOM element to render into.
       * @param {?function} callback function triggered on completion
       * @return {ReactComponent} Component instance rendered in `container`.
       */
      renderComponent: function(nextComponent, container, callback) {
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          if (shouldUpdateReactComponent(prevComponent, nextComponent)) {
            return ReactMount._updateRootComponent(
              prevComponent,
              nextComponent,
              container,
              callback
            );
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(
          nextComponent,
          container,
          shouldReuseMarkup
        );
        callback && callback.call(component);
        return component;
      },
      /**
       * Constructs a component instance of `constructor` with `initialProps` and
       * renders it into the supplied `container`.
       *
       * @param {function} constructor React component constructor.
       * @param {?object} props Initial props of the component instance.
       * @param {DOMElement} container DOM element to render into.
       * @return {ReactComponent} Component instance rendered in `container`.
       */
      constructAndRenderComponent: function(constructor, props, container) {
        return ReactMount.renderComponent(constructor(props), container);
      },
      /**
       * Constructs a component instance of `constructor` with `initialProps` and
       * renders it into a container node identified by supplied `id`.
       *
       * @param {function} componentConstructor React component constructor
       * @param {?object} props Initial props of the component instance.
       * @param {string} id ID of the DOM element to render into.
       * @return {ReactComponent} Component instance rendered in the container node.
       */
      constructAndRenderComponentByID: function(constructor, props, id) {
        var domNode = document.getElementById(id);
        require_React().__DEV__ === true ? invariant(
          domNode,
          'Tried to get element with id of "%s" but it is not present on the page.',
          id
        ) : invariant(domNode);
        return ReactMount.constructAndRenderComponent(constructor, props, domNode);
      },
      /**
       * Registers a container node into which React components will be rendered.
       * This also creates the "reactRoot" ID that will be assigned to the element
       * rendered within.
       *
       * @param {DOMElement} container DOM element to register as a container.
       * @return {string} The "reactRoot" ID of elements rendered within.
       */
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      /**
       * Unmounts and destroys the React component rendered in the `container`.
       *
       * @param {DOMElement} container DOM element containing a React component.
       * @return {boolean} True if a component was found in and unmounted from
       *                   `container`
       */
      unmountComponentAtNode: function(container) {
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if (require_React().__DEV__ === true) {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      /**
       * Unmounts a component and removes it from the DOM.
       *
       * @param {ReactComponent} instance React component instance.
       * @param {DOMElement} container DOM element to unmount from.
       * @final
       * @internal
       * @see {ReactMount.unmountComponentAtNode}
       */
      unmountComponentFromNode: function(instance, container) {
        instance.unmountComponent();
        if (container.nodeType === DOC_NODE_TYPE) {
          container = container.documentElement;
        }
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
      },
      /**
       * Finds the container DOM element that contains React component to which the
       * supplied DOM `id` belongs.
       *
       * @param {string} id The ID of an element rendered by a React component.
       * @return {?DOMElement} DOM element that contains the `id`.
       */
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if (require_React().__DEV__ === true) {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            require_React().__DEV__ === true ? invariant(
              // Call internalGetID here because getID calls isValid which calls
              // findReactContainerForID (this function).
              internalGetID(rootElement) === reactRootID,
              "ReactMount: Root element ID differed from reactRootID."
            ) : invariant(
              // Call internalGetID here because getID calls isValid which calls
              // findReactContainerForID (this function).
              internalGetID(rootElement) === reactRootID
            );
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              console.warn(
                "ReactMount: Root element has been removed from its original container. New container:",
                rootElement.parentNode
              );
            }
          }
        }
        return container;
      },
      /**
       * Finds an element rendered by React with the supplied ID.
       *
       * @param {string} id ID of a DOM node in the React component.
       * @return {DOMElement} Root DOM node of the React component.
       */
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      /**
       * True if the supplied `node` is rendered by React.
       *
       * @param {*} node DOM Element to check.
       * @return {boolean} True if the DOM Element appears to be rendered by React.
       * @internal
       */
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      /**
       * Traverses up the ancestors of the supplied node to find a node that is a
       * DOM representation of a React component.
       *
       * @param {*} node
       * @return {?DOMEventTarget}
       * @internal
       */
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      /**
       * Finds a node with the supplied `targetID` inside of the supplied
       * `ancestorNode`.  Exploits the ID naming scheme to perform the search
       * quickly.
       *
       * @param {DOMEventTarget} ancestorNode Search from this root.
       * @pararm {string} targetID ID of the DOM representation of the component.
       * @return {DOMEventTarget} DOM node with the supplied `targetID`.
       * @internal
       */
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        require_React().__DEV__ === true ? invariant(
          false,
          "findComponentRoot(..., %s): Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a <tbody> when using tables or nesting <p> or <a> tags. Try inspecting the child nodes of the element with React ID `%s`.",
          targetID,
          ReactMount.getID(ancestorNode)
        ) : invariant(false);
      },
      /**
       * React ID utilities.
       */
      getReactRootID,
      getID,
      setID,
      getNode,
      purgeID
    };
    module.exports = ReactMount;
  }
});

// node_modules/react-component/lib/ReactBrowserComponentMixin.js
var require_ReactBrowserComponentMixin = __commonJS({
  "node_modules/react-component/lib/ReactBrowserComponentMixin.js"(exports, module) {
    "use strict";
    var ReactMount = require_ReactMount();
    var invariant = require_invariant();
    var ReactBrowserComponentMixin = {
      /**
       * Returns the DOM node rendered by this component.
       *
       * @return {DOMElement} The root node of this component.
       * @final
       * @protected
       */
      getDOMNode: function() {
        require_React().__DEV__ === true ? invariant(
          this.isMounted(),
          "getDOMNode(): A component must be mounted to have a DOM node."
        ) : invariant(this.isMounted());
        return ReactMount.getNode(this._rootNodeID);
      }
    };
    module.exports = ReactBrowserComponentMixin;
  }
});

// node_modules/react-component/lib/ReactCurrentOwner.js
var require_ReactCurrentOwner = __commonJS({
  "node_modules/react-component/lib/ReactCurrentOwner.js"(exports, module) {
    "use strict";
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    module.exports = ReactCurrentOwner;
  }
});

// node_modules/react-component/lib/emptyObject.js
var require_emptyObject = __commonJS({
  "node_modules/react-component/lib/emptyObject.js"(exports, module) {
    "use strict";
    var emptyObject = {};
    if (require_React().__DEV__ === true) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  }
});

// node_modules/react-component/lib/ReactOwner.js
var require_ReactOwner = __commonJS({
  "node_modules/react-component/lib/ReactOwner.js"(exports, module) {
    "use strict";
    var emptyObject = require_emptyObject();
    var invariant = require_invariant();
    var ReactOwner = {
      /**
       * @param {?object} object
       * @return {boolean} True if `object` is a valid owner.
       * @final
       */
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === "function" && typeof object.detachRef === "function");
      },
      /**
       * Adds a component by ref to an owner component.
       *
       * @param {ReactComponent} component Component to reference.
       * @param {string} ref Name by which to refer to the component.
       * @param {ReactOwner} owner Component on which to record the ref.
       * @final
       * @internal
       */
      addComponentAsRefTo: function(component, ref, owner) {
        require_React().__DEV__ === true ? invariant(
          ReactOwner.isValidOwner(owner),
          "addComponentAsRefTo(...): Only a ReactOwner can have refs. This usually means that you're trying to add a ref to a component that doesn't have an owner (that is, was not created inside of another component's `render` method). Try rendering this component inside of a new top-level component which will hold the ref."
        ) : invariant(ReactOwner.isValidOwner(owner));
        owner.attachRef(ref, component);
      },
      /**
       * Removes a component by ref from an owner component.
       *
       * @param {ReactComponent} component Component to dereference.
       * @param {string} ref Name of the ref to remove.
       * @param {ReactOwner} owner Component on which the ref is recorded.
       * @final
       * @internal
       */
      removeComponentAsRefFrom: function(component, ref, owner) {
        require_React().__DEV__ === true ? invariant(
          ReactOwner.isValidOwner(owner),
          "removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This usually means that you're trying to remove a ref to a component that doesn't have an owner (that is, was not created inside of another component's `render` method). Try rendering this component inside of a new top-level component which will hold the ref."
        ) : invariant(ReactOwner.isValidOwner(owner));
        if (owner.refs[ref] === component) {
          owner.detachRef(ref);
        }
      },
      /**
       * A ReactComponent must mix this in to have refs.
       *
       * @lends {ReactOwner.prototype}
       */
      Mixin: {
        construct: function() {
          this.refs = emptyObject;
        },
        /**
         * Lazily allocates the refs object and stores `component` as `ref`.
         *
         * @param {string} ref Reference name.
         * @param {component} component Component to store as `ref`.
         * @final
         * @private
         */
        attachRef: function(ref, component) {
          require_React().__DEV__ === true ? invariant(
            component.isOwnedBy(this),
            "attachRef(%s, ...): Only a component's owner can store a ref to it.",
            ref
          ) : invariant(component.isOwnedBy(this));
          var refs = this.refs === emptyObject ? this.refs = {} : this.refs;
          refs[ref] = component;
        },
        /**
         * Detaches a reference name.
         *
         * @param {string} ref Name to dereference.
         * @final
         * @private
         */
        detachRef: function(ref) {
          delete this.refs[ref];
        }
      }
    };
    module.exports = ReactOwner;
  }
});

// node_modules/react-component/lib/ReactComponent.js
var require_ReactComponent = __commonJS({
  "node_modules/react-component/lib/ReactComponent.js"(exports, module) {
    "use strict";
    var ReactCurrentOwner = require_ReactCurrentOwner();
    var ReactOwner = require_ReactOwner();
    var ReactUpdates = require_ReactUpdates();
    var invariant = require_invariant();
    var keyMirror = require_keyMirror();
    var merge = require_merge();
    var monitorCodeUse = require_monitorCodeUse();
    var ComponentLifeCycle = keyMirror({
      /**
       * Mounted components have a DOM node representation and are capable of
       * receiving new props.
       */
      MOUNTED: null,
      /**
       * Unmounted components are inactive and cannot receive new props.
       */
      UNMOUNTED: null
    });
    var ownerHasExplicitKeyWarning = {};
    var ownerHasPropertyWarning = {};
    var ownerHasMonitoredObjectMap = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    var injected = false;
    var unmountIDFromEnvironment = null;
    var mountImageIntoNode = null;
    function validateExplicitKey(component) {
      if (component.__keyValidated__ || component.props.key != null) {
        return;
      }
      component.__keyValidated__ = true;
      if (!ReactCurrentOwner.current) {
        return;
      }
      var currentName = ReactCurrentOwner.current.constructor.displayName;
      if (ownerHasExplicitKeyWarning.hasOwnProperty(currentName)) {
        return;
      }
      ownerHasExplicitKeyWarning[currentName] = true;
      var message = 'Each child in an array should have a unique "key" prop. Check the render method of ' + currentName + ".";
      var childOwnerName = null;
      if (!component.isOwnedBy(ReactCurrentOwner.current)) {
        childOwnerName = component._owner && component._owner.constructor.displayName;
        message += " It was passed a child from " + childOwnerName + ".";
      }
      message += " See http://fb.me/react-warning-keys for more information.";
      monitorCodeUse("react_key_warning", {
        component: currentName,
        componentOwner: childOwnerName
      });
      console.warn(message);
    }
    function validatePropertyKey(name) {
      if (NUMERIC_PROPERTY_REGEX.test(name)) {
        var currentName = ReactCurrentOwner.current.constructor.displayName;
        if (ownerHasPropertyWarning.hasOwnProperty(currentName)) {
          return;
        }
        ownerHasPropertyWarning[currentName] = true;
        monitorCodeUse("react_numeric_key_warning");
        console.warn(
          "Child objects should have non-numeric keys so ordering is preserved. Check the render method of " + currentName + ". See http://fb.me/react-warning-keys for more information."
        );
      }
    }
    function monitorUseOfObjectMap() {
      var currentName = ReactCurrentOwner.current && ReactCurrentOwner.current.constructor.displayName || "";
      if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
        return;
      }
      ownerHasMonitoredObjectMap[currentName] = true;
      monitorCodeUse("react_object_map_children");
    }
    function validateChildKeys(component) {
      if (Array.isArray(component)) {
        for (var i = 0; i < component.length; i++) {
          var child = component[i];
          if (ReactComponent.isValidComponent(child)) {
            validateExplicitKey(child);
          }
        }
      } else if (ReactComponent.isValidComponent(component)) {
        component.__keyValidated__ = true;
      } else if (component && typeof component === "object") {
        monitorUseOfObjectMap();
        for (var name in component) {
          validatePropertyKey(name, component);
        }
      }
    }
    var ReactComponent = {
      injection: {
        injectEnvironment: function(ReactComponentEnvironment) {
          require_React().__DEV__ === true ? invariant(
            !injected,
            "ReactComponent: injectEnvironment() can only be called once."
          ) : invariant(!injected);
          mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
          unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;
          ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;
          ReactComponent.ReactReconcileTransaction = ReactComponentEnvironment.ReactReconcileTransaction;
          injected = true;
        }
      },
      /**
       * @param {?object} object
       * @return {boolean} True if `object` is a valid component.
       * @final
       */
      isValidComponent: function(object) {
        if (!object || !object.type || !object.type.prototype) {
          return false;
        }
        var prototype = object.type.prototype;
        return typeof prototype.mountComponentIntoNode === "function" && typeof prototype.receiveComponent === "function";
      },
      /**
       * @internal
       */
      LifeCycle: ComponentLifeCycle,
      /**
       * Injected module that provides ability to mutate individual properties.
       * Injected into the base class because many different subclasses need access
       * to this.
       *
       * @internal
       */
      BackendIDOperations: null,
      /**
       * React references `ReactReconcileTransaction` using this property in order
       * to allow dependency injection.
       *
       * @internal
       */
      ReactReconcileTransaction: null,
      /**
       * Base functionality for every ReactComponent constructor. Mixed into the
       * `ReactComponent` prototype, but exposed statically for easy access.
       *
       * @lends {ReactComponent.prototype}
       */
      Mixin: {
        /**
         * Checks whether or not this component is mounted.
         *
         * @return {boolean} True if mounted, false otherwise.
         * @final
         * @protected
         */
        isMounted: function() {
          return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
        },
        /**
         * Sets a subset of the props.
         *
         * @param {object} partialProps Subset of the next props.
         * @param {?function} callback Called after props are updated.
         * @final
         * @public
         */
        setProps: function(partialProps, callback) {
          this.replaceProps(
            merge(this._pendingProps || this.props, partialProps),
            callback
          );
        },
        /**
         * Replaces all of the props.
         *
         * @param {object} props New props.
         * @param {?function} callback Called after props are updated.
         * @final
         * @public
         */
        replaceProps: function(props, callback) {
          require_React().__DEV__ === true ? invariant(
            this.isMounted(),
            "replaceProps(...): Can only update a mounted component."
          ) : invariant(this.isMounted());
          require_React().__DEV__ === true ? invariant(
            this._mountDepth === 0,
            "replaceProps(...): You called `setProps` or `replaceProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created."
          ) : invariant(this._mountDepth === 0);
          this._pendingProps = props;
          ReactUpdates.enqueueUpdate(this, callback);
        },
        /**
         * Base constructor for all React components.
         *
         * Subclasses that override this method should make sure to invoke
         * `ReactComponent.Mixin.construct.call(this, ...)`.
         *
         * @param {?object} initialProps
         * @param {*} children
         * @internal
         */
        construct: function(initialProps, children) {
          this.props = initialProps || {};
          this._owner = ReactCurrentOwner.current;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
          this._pendingProps = null;
          this._pendingCallbacks = null;
          this._pendingOwner = this._owner;
          var childrenLength = arguments.length - 1;
          if (childrenLength === 1) {
            if (require_React().__DEV__ === true) {
              validateChildKeys(children);
            }
            this.props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              if (require_React().__DEV__ === true) {
                validateChildKeys(arguments[i + 1]);
              }
              childArray[i] = arguments[i + 1];
            }
            this.props.children = childArray;
          }
        },
        /**
         * Initializes the component, renders markup, and registers event listeners.
         *
         * NOTE: This does not insert any nodes into the DOM.
         *
         * Subclasses that override this method should make sure to invoke
         * `ReactComponent.Mixin.mountComponent.call(this, ...)`.
         *
         * @param {string} rootID DOM ID of the root node.
         * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
         * @param {number} mountDepth number of components in the owner hierarchy.
         * @return {?string} Rendered markup to be inserted into the DOM.
         * @internal
         */
        mountComponent: function(rootID, transaction, mountDepth) {
          require_React().__DEV__ === true ? invariant(
            !this.isMounted(),
            "mountComponent(%s, ...): Can only mount an unmounted component. Make sure to avoid storing components between renders or reusing a single component instance in multiple places.",
            rootID
          ) : invariant(!this.isMounted());
          var props = this.props;
          if (props.ref != null) {
            ReactOwner.addComponentAsRefTo(this, props.ref, this._owner);
          }
          this._rootNodeID = rootID;
          this._lifeCycleState = ComponentLifeCycle.MOUNTED;
          this._mountDepth = mountDepth;
        },
        /**
         * Releases any resources allocated by `mountComponent`.
         *
         * NOTE: This does not remove any nodes from the DOM.
         *
         * Subclasses that override this method should make sure to invoke
         * `ReactComponent.Mixin.unmountComponent.call(this)`.
         *
         * @internal
         */
        unmountComponent: function() {
          require_React().__DEV__ === true ? invariant(
            this.isMounted(),
            "unmountComponent(): Can only unmount a mounted component."
          ) : invariant(this.isMounted());
          var props = this.props;
          if (props.ref != null) {
            ReactOwner.removeComponentAsRefFrom(this, props.ref, this._owner);
          }
          unmountIDFromEnvironment(this._rootNodeID);
          this._rootNodeID = null;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
        },
        /**
         * Given a new instance of this component, updates the rendered DOM nodes
         * as if that instance was rendered instead.
         *
         * Subclasses that override this method should make sure to invoke
         * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.
         *
         * @param {object} nextComponent Next set of properties.
         * @param {ReactReconcileTransaction} transaction
         * @internal
         */
        receiveComponent: function(nextComponent, transaction) {
          require_React().__DEV__ === true ? invariant(
            this.isMounted(),
            "receiveComponent(...): Can only update a mounted component."
          ) : invariant(this.isMounted());
          this._pendingOwner = nextComponent._owner;
          this._pendingProps = nextComponent.props;
          this._performUpdateIfNecessary(transaction);
        },
        /**
         * Call `_performUpdateIfNecessary` within a new transaction.
         *
         * @internal
         */
        performUpdateIfNecessary: function() {
          var transaction = ReactComponent.ReactReconcileTransaction.getPooled();
          transaction.perform(this._performUpdateIfNecessary, this, transaction);
          ReactComponent.ReactReconcileTransaction.release(transaction);
        },
        /**
         * If `_pendingProps` is set, update the component.
         *
         * @param {ReactReconcileTransaction} transaction
         * @internal
         */
        _performUpdateIfNecessary: function(transaction) {
          if (this._pendingProps == null) {
            return;
          }
          var prevProps = this.props;
          var prevOwner = this._owner;
          this.props = this._pendingProps;
          this._owner = this._pendingOwner;
          this._pendingProps = null;
          this.updateComponent(transaction, prevProps, prevOwner);
        },
        /**
         * Updates the component's currently mounted representation.
         *
         * @param {ReactReconcileTransaction} transaction
         * @param {object} prevProps
         * @internal
         */
        updateComponent: function(transaction, prevProps, prevOwner) {
          var props = this.props;
          if (this._owner !== prevOwner || props.ref !== prevProps.ref) {
            if (prevProps.ref != null) {
              ReactOwner.removeComponentAsRefFrom(
                this,
                prevProps.ref,
                prevOwner
              );
            }
            if (props.ref != null) {
              ReactOwner.addComponentAsRefTo(this, props.ref, this._owner);
            }
          }
        },
        /**
         * Mounts this component and inserts it into the DOM.
         *
         * @param {string} rootID DOM ID of the root node.
         * @param {DOMElement} container DOM element to mount into.
         * @param {boolean} shouldReuseMarkup If true, do not insert markup
         * @final
         * @internal
         * @see {ReactMount.renderComponent}
         */
        mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
          var transaction = ReactComponent.ReactReconcileTransaction.getPooled();
          transaction.perform(
            this._mountComponentIntoNode,
            this,
            rootID,
            container,
            transaction,
            shouldReuseMarkup
          );
          ReactComponent.ReactReconcileTransaction.release(transaction);
        },
        /**
         * @param {string} rootID DOM ID of the root node.
         * @param {DOMElement} container DOM element to mount into.
         * @param {ReactReconcileTransaction} transaction
         * @param {boolean} shouldReuseMarkup If true, do not insert markup
         * @final
         * @private
         */
        _mountComponentIntoNode: function(rootID, container, transaction, shouldReuseMarkup) {
          var markup = this.mountComponent(rootID, transaction, 0);
          mountImageIntoNode(markup, container, shouldReuseMarkup);
        },
        /**
         * Checks if this component is owned by the supplied `owner` component.
         *
         * @param {ReactComponent} owner Component to check.
         * @return {boolean} True if `owners` owns this component.
         * @final
         * @internal
         */
        isOwnedBy: function(owner) {
          return this._owner === owner;
        },
        /**
         * Gets another component, that shares the same owner as this one, by ref.
         *
         * @param {string} ref of a sibling Component.
         * @return {?ReactComponent} the actual sibling Component.
         * @final
         * @internal
         */
        getSiblingByRef: function(ref) {
          var owner = this._owner;
          if (!owner || !owner.refs) {
            return null;
          }
          return owner.refs[ref];
        }
      }
    };
    module.exports = ReactComponent;
  }
});

// node_modules/react-component/lib/mixInto.js
var require_mixInto = __commonJS({
  "node_modules/react-component/lib/mixInto.js"(exports, module) {
    "use strict";
    var mixInto = function(constructor, methodBag) {
      var methodName;
      for (methodName in methodBag) {
        if (!methodBag.hasOwnProperty(methodName)) {
          continue;
        }
        constructor.prototype[methodName] = methodBag[methodName];
      }
    };
    module.exports = mixInto;
  }
});

// node_modules/react-component/lib/ReactTextComponent.js
var require_ReactTextComponent = __commonJS({
  "node_modules/react-component/lib/ReactTextComponent.js"(exports, module) {
    "use strict";
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactComponent = require_ReactComponent();
    var escapeTextForBrowser = require_escapeTextForBrowser();
    var mixInto = require_mixInto();
    var ReactTextComponent = function(initialText) {
      this.construct({ text: initialText });
    };
    ReactTextComponent.ConvenienceConstructor = function(props) {
      return new ReactTextComponent(props.text);
    };
    mixInto(ReactTextComponent, ReactComponent.Mixin);
    mixInto(ReactTextComponent, ReactBrowserComponentMixin);
    mixInto(ReactTextComponent, {
      /**
       * Creates the markup for this text node. This node is not intended to have
       * any features besides containing text content.
       *
       * @param {string} rootID DOM ID of the root node.
       * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
       * @param {number} mountDepth number of components in the owner hierarchy
       * @return {string} Markup for this text node.
       * @internal
       */
      mountComponent: function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(
          this,
          rootID,
          transaction,
          mountDepth
        );
        var escapedText = escapeTextForBrowser(this.props.text);
        if (transaction.renderToStaticMarkup) {
          return escapedText;
        }
        return "<span " + DOMPropertyOperations.createMarkupForID(rootID) + ">" + escapedText + "</span>";
      },
      /**
       * Updates this component by updating the text content.
       *
       * @param {object} nextComponent Contains the next text content.
       * @param {ReactReconcileTransaction} transaction
       * @internal
       */
      receiveComponent: function(nextComponent, transaction) {
        var nextProps = nextComponent.props;
        if (nextProps.text !== this.props.text) {
          this.props.text = nextProps.text;
          ReactComponent.BackendIDOperations.updateTextContentByID(
            this._rootNodeID,
            nextProps.text
          );
        }
      }
    });
    ReactTextComponent.type = ReactTextComponent;
    ReactTextComponent.prototype.type = ReactTextComponent;
    module.exports = ReactTextComponent;
  }
});

// node_modules/react-component/lib/traverseAllChildren.js
var require_traverseAllChildren = __commonJS({
  "node_modules/react-component/lib/traverseAllChildren.js"(exports, module) {
    "use strict";
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactTextComponent = require_ReactTextComponent();
    var invariant = require_invariant();
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ":";
    var userProvidedKeyEscaperLookup = {
      "=": "=0",
      ".": "=1",
      ":": "=2"
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.props && component.props.key != null) {
        return wrapUserProvidedKey(component.props.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ("" + text).replace(
        userProvidedKeyEscapeRegex,
        userProvidedKeyEscaper
      );
    }
    function wrapUserProvidedKey(key) {
      return "$" + escapeUserProvidedKey(key);
    }
    var traverseAllChildrenImpl = function(children, nameSoFar, indexSoFar, callback, traverseContext) {
      var subtreeCount = 0;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);
          var nextIndex = indexSoFar + subtreeCount;
          subtreeCount += traverseAllChildrenImpl(
            child,
            nextName,
            nextIndex,
            callback,
            traverseContext
          );
        }
      } else {
        var type = typeof children;
        var isOnlyChild = nameSoFar === "";
        var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
        if (children == null || type === "boolean") {
          callback(traverseContext, null, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (children.type && children.type.prototype && children.type.prototype.mountComponentIntoNode) {
          callback(traverseContext, children, storageName, indexSoFar);
          subtreeCount = 1;
        } else {
          if (type === "object") {
            require_React().__DEV__ === true ? invariant(
              !children || children.nodeType !== 1,
              "traverseAllChildren(...): Encountered an invalid child; DOM elements are not valid children of React components."
            ) : invariant(!children || children.nodeType !== 1);
            for (var key in children) {
              if (children.hasOwnProperty(key)) {
                subtreeCount += traverseAllChildrenImpl(
                  children[key],
                  nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0),
                  indexSoFar + subtreeCount,
                  callback,
                  traverseContext
                );
              }
            }
          } else if (type === "string") {
            var normalizedText = new ReactTextComponent(children);
            callback(traverseContext, normalizedText, storageName, indexSoFar);
            subtreeCount += 1;
          } else if (type === "number") {
            var normalizedNumber = new ReactTextComponent("" + children);
            callback(traverseContext, normalizedNumber, storageName, indexSoFar);
            subtreeCount += 1;
          }
        }
      }
      return subtreeCount;
    };
    function traverseAllChildren(children, callback, traverseContext) {
      if (children !== null && children !== void 0) {
        traverseAllChildrenImpl(children, "", 0, callback, traverseContext);
      }
    }
    module.exports = traverseAllChildren;
  }
});

// node_modules/react-component/lib/ReactChildren.js
var require_ReactChildren = __commonJS({
  "node_modules/react-component/lib/ReactChildren.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var invariant = require_invariant();
    var traverseAllChildren = require_traverseAllChildren();
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.forEachFunction = forEachFunction;
      this.forEachContext = forEachContext;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
      var forEachBookKeeping = traverseContext;
      forEachBookKeeping.forEachFunction.call(
        forEachBookKeeping.forEachContext,
        child,
        i
      );
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.mapResult = mapResult;
      this.mapFunction = mapFunction;
      this.mapContext = mapContext;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
      var mapBookKeeping = traverseContext;
      var mapResult = mapBookKeeping.mapResult;
      var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
      require_React().__DEV__ === true ? invariant(
        !mapResult.hasOwnProperty(name),
        "ReactChildren.map(...): Encountered two children with the same key, `%s`. Children keys must be unique.",
        name
      ) : invariant(!mapResult.hasOwnProperty(name));
      mapResult[name] = mappedChild;
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return mapResult;
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren
    };
    module.exports = ReactChildren;
  }
});

// node_modules/react-component/lib/ReactErrorUtils.js
var require_ReactErrorUtils = __commonJS({
  "node_modules/react-component/lib/ReactErrorUtils.js"(exports, module) {
    "use strict";
    var ReactErrorUtils = {
      /**
       * Creates a guarded version of a function. This is supposed to make debugging
       * of event handlers easier. To aid debugging with the browser's debugger,
       * this currently simply returns the original function.
       *
       * @param {function} func Function to be executed
       * @param {string} name The name of the guard
       * @return {function}
       */
      guard: function(func, name) {
        return func;
      }
    };
    module.exports = ReactErrorUtils;
  }
});

// node_modules/react-component/lib/joinClasses.js
var require_joinClasses = __commonJS({
  "node_modules/react-component/lib/joinClasses.js"(exports, module) {
    "use strict";
    function joinClasses(className) {
      if (!className) {
        className = "";
      }
      var nextClass;
      var argLength = arguments.length;
      if (argLength > 1) {
        for (var ii = 1; ii < argLength; ii++) {
          nextClass = arguments[ii];
          nextClass && (className += " " + nextClass);
        }
      }
      return className;
    }
    module.exports = joinClasses;
  }
});

// node_modules/react-component/lib/ReactPropTransferer.js
var require_ReactPropTransferer = __commonJS({
  "node_modules/react-component/lib/ReactPropTransferer.js"(exports, module) {
    "use strict";
    var emptyFunction = require_emptyFunction();
    var invariant = require_invariant();
    var joinClasses = require_joinClasses();
    var merge = require_merge();
    function createTransferStrategy(mergeStrategy) {
      return function(props, key, value) {
        if (!props.hasOwnProperty(key)) {
          props[key] = value;
        } else {
          props[key] = mergeStrategy(props[key], value);
        }
      };
    }
    var TransferStrategies = {
      /**
       * Never transfer `children`.
       */
      children: emptyFunction,
      /**
       * Transfer the `className` prop by merging them.
       */
      className: createTransferStrategy(joinClasses),
      /**
       * Never transfer the `key` prop.
       */
      key: emptyFunction,
      /**
       * Never transfer the `ref` prop.
       */
      ref: emptyFunction,
      /**
       * Transfer the `style` prop (which is an object) by merging them.
       */
      style: createTransferStrategy(merge)
    };
    var ReactPropTransferer = {
      TransferStrategies,
      /**
       * Merge two props objects using TransferStrategies.
       *
       * @param {object} oldProps original props (they take precedence)
       * @param {object} newProps new props to merge in
       * @return {object} a new object containing both sets of props merged.
       */
      mergeProps: function(oldProps, newProps) {
        var props = merge(oldProps);
        for (var thisKey in newProps) {
          if (!newProps.hasOwnProperty(thisKey)) {
            continue;
          }
          var transferStrategy = TransferStrategies[thisKey];
          if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
            transferStrategy(props, thisKey, newProps[thisKey]);
          } else if (!props.hasOwnProperty(thisKey)) {
            props[thisKey] = newProps[thisKey];
          }
        }
        return props;
      },
      /**
       * @lends {ReactPropTransferer.prototype}
       */
      Mixin: {
        /**
         * Transfer props from this component to a target component.
         *
         * Props that do not have an explicit transfer strategy will be transferred
         * only if the target component does not already have the prop set.
         *
         * This is usually used to pass down props to a returned root component.
         *
         * @param {ReactComponent} component Component receiving the properties.
         * @return {ReactComponent} The supplied `component`.
         * @final
         * @protected
         */
        transferPropsTo: function(component) {
          require_React().__DEV__ === true ? invariant(
            component._owner === this,
            "%s: You can't call transferPropsTo() on a component that you don't own, %s. This usually means you are calling transferPropsTo() on a component passed in as props or children.",
            this.constructor.displayName,
            component.constructor.displayName
          ) : invariant(component._owner === this);
          component.props = ReactPropTransferer.mergeProps(
            component.props,
            this.props
          );
          return component;
        }
      }
    };
    module.exports = ReactPropTransferer;
  }
});

// node_modules/react-component/lib/ReactPropTypeLocations.js
var require_ReactPropTypeLocations = __commonJS({
  "node_modules/react-component/lib/ReactPropTypeLocations.js"(exports, module) {
    "use strict";
    var keyMirror = require_keyMirror();
    var ReactPropTypeLocations = keyMirror({
      prop: null,
      context: null,
      childContext: null
    });
    module.exports = ReactPropTypeLocations;
  }
});

// node_modules/react-component/lib/ReactPropTypeLocationNames.js
var require_ReactPropTypeLocationNames = __commonJS({
  "node_modules/react-component/lib/ReactPropTypeLocationNames.js"(exports, module) {
    "use strict";
    var ReactPropTypeLocationNames = {};
    if (require_React().__DEV__ === true) {
      ReactPropTypeLocationNames = {
        prop: "prop",
        context: "context",
        childContext: "child context"
      };
    }
    module.exports = ReactPropTypeLocationNames;
  }
});

// node_modules/react-component/lib/objMap.js
var require_objMap = __commonJS({
  "node_modules/react-component/lib/objMap.js"(exports, module) {
    "use strict";
    function objMap(obj, func, context) {
      if (!obj) {
        return null;
      }
      var i = 0;
      var ret = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = func.call(context, obj[key], key, i++);
        }
      }
      return ret;
    }
    module.exports = objMap;
  }
});

// node_modules/react-component/lib/ReactCompositeComponent.js
var require_ReactCompositeComponent = __commonJS({
  "node_modules/react-component/lib/ReactCompositeComponent.js"(exports, module) {
    "use strict";
    var ReactComponent = require_ReactComponent();
    var ReactContext = require_ReactContext();
    var ReactCurrentOwner = require_ReactCurrentOwner();
    var ReactErrorUtils = require_ReactErrorUtils();
    var ReactOwner = require_ReactOwner();
    var ReactPerf = require_ReactPerf();
    var ReactPropTransferer = require_ReactPropTransferer();
    var ReactPropTypeLocations = require_ReactPropTypeLocations();
    var ReactPropTypeLocationNames = require_ReactPropTypeLocationNames();
    var ReactUpdates = require_ReactUpdates();
    var instantiateReactComponent = require_instantiateReactComponent();
    var invariant = require_invariant();
    var keyMirror = require_keyMirror();
    var merge = require_merge();
    var mixInto = require_mixInto();
    var monitorCodeUse = require_monitorCodeUse();
    var objMap = require_objMap();
    var shouldUpdateReactComponent = require_shouldUpdateReactComponent();
    var warning = require_warning();
    var SpecPolicy = keyMirror({
      /**
       * These methods may be defined only once by the class specification or mixin.
       */
      DEFINE_ONCE: null,
      /**
       * These methods may be defined by both the class specification and mixins.
       * Subsequent definitions will be chained. These methods must return void.
       */
      DEFINE_MANY: null,
      /**
       * These methods are overriding the base ReactCompositeComponent class.
       */
      OVERRIDE_BASE: null,
      /**
       * These methods are similar to DEFINE_MANY, except we assume they return
       * objects. We try to merge the keys of the return values of all the mixed in
       * functions. If there is a key conflict we throw.
       */
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var ReactCompositeComponentInterface = {
      /**
       * An array of Mixin objects to include when defining your component.
       *
       * @type {array}
       * @optional
       */
      mixins: SpecPolicy.DEFINE_MANY,
      /**
       * An object containing properties and methods that should be defined on
       * the component's constructor instead of its prototype (static methods).
       *
       * @type {object}
       * @optional
       */
      statics: SpecPolicy.DEFINE_MANY,
      /**
       * Definition of prop types for this component.
       *
       * @type {object}
       * @optional
       */
      propTypes: SpecPolicy.DEFINE_MANY,
      /**
       * Definition of context types for this component.
       *
       * @type {object}
       * @optional
       */
      contextTypes: SpecPolicy.DEFINE_MANY,
      /**
       * Definition of context types this component sets for its children.
       *
       * @type {object}
       * @optional
       */
      childContextTypes: SpecPolicy.DEFINE_MANY,
      // ==== Definition methods ====
      /**
       * Invoked when the component is mounted. Values in the mapping will be set on
       * `this.props` if that prop is not specified (i.e. using an `in` check).
       *
       * This method is invoked before `getInitialState` and therefore cannot rely
       * on `this.state` or use `this.setState`.
       *
       * @return {object}
       * @optional
       */
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      /**
       * Invoked once before the component is mounted. The return value will be used
       * as the initial value of `this.state`.
       *
       *   getInitialState: function() {
       *     return {
       *       isOn: false,
       *       fooBaz: new BazFoo()
       *     }
       *   }
       *
       * @return {object}
       * @optional
       */
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      /**
       * @return {object}
       * @optional
       */
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      /**
       * Uses props from `this.props` and state from `this.state` to render the
       * structure of the component.
       *
       * No guarantees are made about when or how often this method is invoked, so
       * it must not have side effects.
       *
       *   render: function() {
       *     var name = this.props.name;
       *     return <div>Hello, {name}!</div>;
       *   }
       *
       * @return {ReactComponent}
       * @nosideeffects
       * @required
       */
      render: SpecPolicy.DEFINE_ONCE,
      // ==== Delegate methods ====
      /**
       * Invoked when the component is initially created and about to be mounted.
       * This may have side effects, but any external subscriptions or data created
       * by this method must be cleaned up in `componentWillUnmount`.
       *
       * @optional
       */
      componentWillMount: SpecPolicy.DEFINE_MANY,
      /**
       * Invoked when the component has been mounted and has a DOM representation.
       * However, there is no guarantee that the DOM node is in the document.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been mounted (initialized and rendered) for the first time.
       *
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidMount: SpecPolicy.DEFINE_MANY,
      /**
       * Invoked before the component receives new props.
       *
       * Use this as an opportunity to react to a prop transition by updating the
       * state using `this.setState`. Current props are accessed via `this.props`.
       *
       *   componentWillReceiveProps: function(nextProps, nextContext) {
       *     this.setState({
       *       likesIncreasing: nextProps.likeCount > this.props.likeCount
       *     });
       *   }
       *
       * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
       * transition may cause a state change, but the opposite is not true. If you
       * need it, you are probably looking for `componentWillUpdate`.
       *
       * @param {object} nextProps
       * @optional
       */
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      /**
       * Invoked while deciding if the component should be updated as a result of
       * receiving new props, state and/or context.
       *
       * Use this as an opportunity to `return false` when you're certain that the
       * transition to the new props/state/context will not require a component
       * update.
       *
       *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
       *     return !equal(nextProps, this.props) ||
       *       !equal(nextState, this.state) ||
       *       !equal(nextContext, this.context);
       *   }
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @return {boolean} True if the component should update.
       * @optional
       */
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      /**
       * Invoked when the component is about to update due to a transition from
       * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
       * and `nextContext`.
       *
       * Use this as an opportunity to perform preparation before an update occurs.
       *
       * NOTE: You **cannot** use `this.setState()` in this method.
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @param {ReactReconcileTransaction} transaction
       * @optional
       */
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      /**
       * Invoked when the component's DOM representation has been updated.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been updated.
       *
       * @param {object} prevProps
       * @param {?object} prevState
       * @param {?object} prevContext
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      /**
       * Invoked when the component is about to be removed from its parent and have
       * its DOM representation destroyed.
       *
       * Use this as an opportunity to deallocate any external resources.
       *
       * NOTE: There is no `componentDidUnmount` since your component will have been
       * destroyed by that point.
       *
       * @optional
       */
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      // ==== Advanced methods ====
      /**
       * Updates the component's currently mounted DOM representation.
       *
       * By default, this implements React's rendering and reconciliation algorithm.
       * Sophisticated clients may wish to override this.
       *
       * @param {ReactReconcileTransaction} transaction
       * @internal
       * @overridable
       */
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(ConvenienceConstructor, displayName) {
        ConvenienceConstructor.componentConstructor.displayName = displayName;
      },
      mixins: function(ConvenienceConstructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(ConvenienceConstructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(ConvenienceConstructor, childContextTypes) {
        var Constructor = ConvenienceConstructor.componentConstructor;
        validateTypeDef(
          Constructor,
          childContextTypes,
          ReactPropTypeLocations.childContext
        );
        Constructor.childContextTypes = merge(
          Constructor.childContextTypes,
          childContextTypes
        );
      },
      contextTypes: function(ConvenienceConstructor, contextTypes) {
        var Constructor = ConvenienceConstructor.componentConstructor;
        validateTypeDef(
          Constructor,
          contextTypes,
          ReactPropTypeLocations.context
        );
        Constructor.contextTypes = merge(Constructor.contextTypes, contextTypes);
      },
      propTypes: function(ConvenienceConstructor, propTypes) {
        var Constructor = ConvenienceConstructor.componentConstructor;
        validateTypeDef(
          Constructor,
          propTypes,
          ReactPropTypeLocations.prop
        );
        Constructor.propTypes = merge(Constructor.propTypes, propTypes);
      },
      statics: function(ConvenienceConstructor, statics) {
        mixStaticSpecIntoComponent(ConvenienceConstructor, statics);
      }
    };
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          require_React().__DEV__ === true ? invariant(
            typeof typeDef[propName] == "function",
            "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.",
            Constructor.displayName || "ReactCompositeComponent",
            ReactPropTypeLocationNames[location],
            propName
          ) : invariant(typeof typeDef[propName] == "function");
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactCompositeComponentInterface[name];
      if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
        require_React().__DEV__ === true ? invariant(
          specPolicy === SpecPolicy.OVERRIDE_BASE,
          "ReactCompositeComponentInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.",
          name
        ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE);
      }
      if (proto.hasOwnProperty(name)) {
        require_React().__DEV__ === true ? invariant(
          specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED,
          "ReactCompositeComponentInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",
          name
        ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED);
      }
    }
    function validateLifeCycleOnReplaceState(instance) {
      var compositeLifeCycleState = instance._compositeLifeCycleState;
      require_React().__DEV__ === true ? invariant(
        instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
        "replaceState(...): Can only update a mounted or mounting component."
      ) : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);
      require_React().__DEV__ === true ? invariant(
        compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE,
        "replaceState(...): Cannot update during an existing state transition (such as within `render`). This could potentially cause an infinite loop so it is forbidden."
      ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE);
      require_React().__DEV__ === true ? invariant(
        compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
        "replaceState(...): Cannot update while unmounting component. This usually means you called setState() on an unmounted component."
      ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING);
    }
    function mixSpecIntoComponent(ConvenienceConstructor, spec) {
      require_React().__DEV__ === true ? invariant(
        !isValidClass(spec),
        "ReactCompositeComponent: You're attempting to use a component class as a mixin. Instead, just use a regular object."
      ) : invariant(!isValidClass(spec));
      require_React().__DEV__ === true ? invariant(
        !ReactComponent.isValidComponent(spec),
        "ReactCompositeComponent: You're attempting to use a component as a mixin. Instead, just use a regular object."
      ) : invariant(!ReactComponent.isValidComponent(spec));
      var Constructor = ConvenienceConstructor.componentConstructor;
      var proto = Constructor.prototype;
      for (var name in spec) {
        var property = spec[name];
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](ConvenienceConstructor, property);
        } else {
          var isCompositeComponentMethod = name in ReactCompositeComponentInterface;
          var isInherited = name in proto;
          var markedDontBind = property && property.__reactDontBind;
          var isFunction = typeof property === "function";
          var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isInherited && !markedDontBind;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isInherited) {
              if (ReactCompositeComponentInterface[name] === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(ConvenienceConstructor, statics) {
      if (!statics) {
        return;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          return;
        }
        var isInherited = name in ConvenienceConstructor;
        var result = property;
        if (isInherited) {
          var existingProperty = ConvenienceConstructor[name];
          var existingType = typeof existingProperty;
          var propertyType = typeof property;
          require_React().__DEV__ === true ? invariant(
            existingType === "function" && propertyType === "function",
            "ReactCompositeComponent: You are attempting to define `%s` on your component more than once, but that is only supported for functions, which are chained together. This conflict may be due to a mixin.",
            name
          ) : invariant(existingType === "function" && propertyType === "function");
          result = createChainedFunction(existingProperty, property);
        }
        ConvenienceConstructor[name] = result;
        ConvenienceConstructor.componentConstructor[name] = result;
      }
    }
    function mergeObjectsWithNoDuplicateKeys(one, two) {
      require_React().__DEV__ === true ? invariant(
        one && two && typeof one === "object" && typeof two === "object",
        "mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects"
      ) : invariant(one && two && typeof one === "object" && typeof two === "object");
      objMap(two, function(value, key) {
        require_React().__DEV__ === true ? invariant(
          one[key] === void 0,
          "mergeObjectsWithNoDuplicateKeys(): Tried to merge two objects with the same key: %s",
          key
        ) : invariant(one[key] === void 0);
        one[key] = value;
      });
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        return mergeObjectsWithNoDuplicateKeys(a, b);
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    if (require_React().__DEV__ === true) {
      unmountedPropertyWhitelist = {
        constructor: true,
        construct: true,
        isOwnedBy: true,
        // should be deprecated but can have code mod (internal)
        type: true,
        props: true,
        // currently private but belong on the descriptor and are valid for use
        // inside the framework:
        __keyValidated__: true,
        _owner: true,
        _currentContext: true
      };
      componentInstanceProperties = {
        __keyValidated__: true,
        __keySetters: true,
        _compositeLifeCycleState: true,
        _currentContext: true,
        _defaultProps: true,
        _instance: true,
        _lifeCycleState: true,
        _mountDepth: true,
        _owner: true,
        _pendingCallbacks: true,
        _pendingContext: true,
        _pendingForceUpdate: true,
        _pendingOwner: true,
        _pendingProps: true,
        _pendingState: true,
        _renderedComponent: true,
        _rootNodeID: true,
        context: true,
        props: true,
        refs: true,
        state: true,
        // These are known instance properties coming from other sources
        _pendingQueries: true,
        _queryPropListeners: true,
        queryParams: true
      };
      hasWarnedOnComponentType = {};
      warningStackCounter = 0;
      issueMembraneWarning = function(instance, key) {
        var isWhitelisted = unmountedPropertyWhitelist.hasOwnProperty(key);
        if (warningStackCounter > 0 || isWhitelisted) {
          return;
        }
        var name = instance.constructor.displayName || "Unknown";
        var owner = ReactCurrentOwner.current;
        var ownerName = owner && owner.constructor.displayName || "Unknown";
        var warningKey = key + "|" + name + "|" + ownerName;
        if (hasWarnedOnComponentType.hasOwnProperty(warningKey)) {
          return;
        }
        hasWarnedOnComponentType[warningKey] = true;
        var context = owner ? " in " + ownerName + "." : " at the top level.";
        var staticMethodExample = "<" + name + " />.type." + key + "(...)";
        monitorCodeUse("react_descriptor_property_access", { component: name });
        console.warn(
          'Invalid access to component property "' + key + '" on ' + name + context + " See http://fb.me/react-warning-descriptors . Use a static method instead: " + staticMethodExample
        );
      };
      wrapInMembraneFunction = function(fn, thisBinding) {
        if (fn.__reactMembraneFunction && fn.__reactMembraneSelf === thisBinding) {
          return fn.__reactMembraneFunction;
        }
        return fn.__reactMembraneFunction = function() {
          warningStackCounter++;
          try {
            var self = this === thisBinding ? this.__realComponentInstance : this;
            return fn.apply(self, arguments);
          } finally {
            warningStackCounter--;
          }
        };
      };
      defineMembraneProperty = function(membrane, prototype, key) {
        Object.defineProperty(membrane, key, {
          configurable: false,
          enumerable: true,
          get: function() {
            if (this === membrane) {
              return prototype[key];
            }
            issueMembraneWarning(this, key);
            var realValue = this.__realComponentInstance[key];
            if (typeof realValue === "function" && key !== "type" && key !== "constructor") {
              return wrapInMembraneFunction(realValue, this);
            }
            return realValue;
          },
          set: function(value) {
            if (this === membrane) {
              prototype[key] = value;
              return;
            }
            issueMembraneWarning(this, key);
            this.__realComponentInstance[key] = value;
          }
        });
      };
      createMountWarningMembrane = function(prototype) {
        var membrane = {};
        var key;
        for (key in prototype) {
          defineMembraneProperty(membrane, prototype, key);
        }
        for (key in componentInstanceProperties) {
          if (componentInstanceProperties.hasOwnProperty(key) && !(key in prototype)) {
            defineMembraneProperty(membrane, prototype, key);
          }
        }
        return membrane;
      };
      createDescriptorProxy = function(constructor) {
        try {
          var ProxyConstructor = function() {
            this.__realComponentInstance = new constructor();
            Object.freeze(this);
          };
          ProxyConstructor.prototype = createMountWarningMembrane(
            constructor.prototype
          );
          return ProxyConstructor;
        } catch (x) {
          return constructor;
        }
      };
    }
    var unmountedPropertyWhitelist;
    var componentInstanceProperties;
    var hasWarnedOnComponentType;
    var warningStackCounter;
    var issueMembraneWarning;
    var wrapInMembraneFunction;
    var defineMembraneProperty;
    var createMountWarningMembrane;
    var createDescriptorProxy;
    var CompositeLifeCycle = keyMirror({
      /**
       * Components in the process of being mounted respond to state changes
       * differently.
       */
      MOUNTING: null,
      /**
       * Components in the process of being unmounted are guarded against state
       * changes.
       */
      UNMOUNTING: null,
      /**
       * Components that are mounted and receiving new props respond to state
       * changes differently.
       */
      RECEIVING_PROPS: null,
      /**
       * Components that are mounted and receiving new state are guarded against
       * additional state changes.
       */
      RECEIVING_STATE: null
    });
    var ReactCompositeComponentMixin = {
      /**
       * Base constructor for all composite component.
       *
       * @param {?object} initialProps
       * @param {*} children
       * @final
       * @internal
       */
      construct: function(initialProps, children) {
        ReactComponent.Mixin.construct.apply(this, arguments);
        ReactOwner.Mixin.construct.apply(this, arguments);
        this.state = null;
        this._pendingState = null;
        this.context = null;
        this._currentContext = ReactContext.current;
        this._pendingContext = null;
        this._descriptor = null;
        this._compositeLifeCycleState = null;
      },
      /**
       * Components in the intermediate state now has cyclic references. To avoid
       * breaking JSON serialization we expose a custom JSON format.
       * @return {object} JSON compatible representation.
       * @internal
       * @final
       */
      toJSON: function() {
        return { type: this.type, props: this.props };
      },
      /**
       * Checks whether or not this composite component is mounted.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function() {
        return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
      },
      /**
       * Initializes the component, renders markup, and registers event listeners.
       *
       * @param {string} rootID DOM ID of the root node.
       * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
       * @param {number} mountDepth number of components in the owner hierarchy
       * @return {?string} Rendered markup to be inserted into the DOM.
       * @final
       * @internal
       */
      mountComponent: ReactPerf.measure(
        "ReactCompositeComponent",
        "mountComponent",
        function(rootID, transaction, mountDepth) {
          ReactComponent.Mixin.mountComponent.call(
            this,
            rootID,
            transaction,
            mountDepth
          );
          this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;
          this.context = this._processContext(this._currentContext);
          this._defaultProps = this.getDefaultProps ? this.getDefaultProps() : null;
          this.props = this._processProps(this.props);
          if (this.__reactAutoBindMap) {
            this._bindAutoBindMethods();
          }
          this.state = this.getInitialState ? this.getInitialState() : null;
          require_React().__DEV__ === true ? invariant(
            typeof this.state === "object" && !Array.isArray(this.state),
            "%s.getInitialState(): must return an object or null",
            this.constructor.displayName || "ReactCompositeComponent"
          ) : invariant(typeof this.state === "object" && !Array.isArray(this.state));
          this._pendingState = null;
          this._pendingForceUpdate = false;
          if (this.componentWillMount) {
            this.componentWillMount();
            if (this._pendingState) {
              this.state = this._pendingState;
              this._pendingState = null;
            }
          }
          this._renderedComponent = instantiateReactComponent(
            this._renderValidatedComponent()
          );
          this._compositeLifeCycleState = null;
          var markup = this._renderedComponent.mountComponent(
            rootID,
            transaction,
            mountDepth + 1
          );
          if (this.componentDidMount) {
            transaction.getReactMountReady().enqueue(this, this.componentDidMount);
          }
          return markup;
        }
      ),
      /**
       * Releases any resources allocated by `mountComponent`.
       *
       * @final
       * @internal
       */
      unmountComponent: function() {
        this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
        if (this.componentWillUnmount) {
          this.componentWillUnmount();
        }
        this._compositeLifeCycleState = null;
        this._defaultProps = null;
        this._renderedComponent.unmountComponent();
        this._renderedComponent = null;
        ReactComponent.Mixin.unmountComponent.call(this);
      },
      /**
       * Sets a subset of the state. Always use this or `replaceState` to mutate
       * state. You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * There is no guarantee that calls to `setState` will run synchronously,
       * as they may eventually be batched together.  You can provide an optional
       * callback that will be executed when the call to setState is actually
       * completed.
       *
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after state is updated.
       * @final
       * @protected
       */
      setState: function(partialState, callback) {
        require_React().__DEV__ === true ? invariant(
          typeof partialState === "object" || partialState == null,
          "setState(...): takes an object of state variables to update."
        ) : invariant(typeof partialState === "object" || partialState == null);
        if (require_React().__DEV__ === true) {
          require_React().__DEV__ === true ? warning(
            partialState != null,
            "setState(...): You passed an undefined or null state object; instead, use forceUpdate()."
          ) : null;
        }
        this.replaceState(
          merge(this._pendingState || this.state, partialState),
          callback
        );
      },
      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {object} completeState Next state.
       * @param {?function} callback Called after state is updated.
       * @final
       * @protected
       */
      replaceState: function(completeState, callback) {
        validateLifeCycleOnReplaceState(this);
        this._pendingState = completeState;
        ReactUpdates.enqueueUpdate(this, callback);
      },
      /**
       * Filters the context object to only contain keys specified in
       * `contextTypes`, and asserts that they are valid.
       *
       * @param {object} context
       * @return {?object}
       * @private
       */
      _processContext: function(context) {
        var maskedContext = null;
        var contextTypes = this.constructor.contextTypes;
        if (contextTypes) {
          maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          if (require_React().__DEV__ === true) {
            this._checkPropTypes(
              contextTypes,
              maskedContext,
              ReactPropTypeLocations.context
            );
          }
        }
        return maskedContext;
      },
      /**
       * @param {object} currentContext
       * @return {object}
       * @private
       */
      _processChildContext: function(currentContext) {
        var childContext = this.getChildContext && this.getChildContext();
        var displayName = this.constructor.displayName || "ReactCompositeComponent";
        if (childContext) {
          require_React().__DEV__ === true ? invariant(
            typeof this.constructor.childContextTypes === "object",
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            displayName
          ) : invariant(typeof this.constructor.childContextTypes === "object");
          if (require_React().__DEV__ === true) {
            this._checkPropTypes(
              this.constructor.childContextTypes,
              childContext,
              ReactPropTypeLocations.childContext
            );
          }
          for (var name in childContext) {
            require_React().__DEV__ === true ? invariant(
              name in this.constructor.childContextTypes,
              '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
              displayName,
              name
            ) : invariant(name in this.constructor.childContextTypes);
          }
          return merge(currentContext, childContext);
        }
        return currentContext;
      },
      /**
       * Processes props by setting default values for unspecified props and
       * asserting that the props are valid. Does not mutate its argument; returns
       * a new props object with defaults merged in.
       *
       * @param {object} newProps
       * @return {object}
       * @private
       */
      _processProps: function(newProps) {
        var props = merge(newProps);
        var defaultProps = this._defaultProps;
        for (var propName in defaultProps) {
          if (typeof props[propName] === "undefined") {
            props[propName] = defaultProps[propName];
          }
        }
        if (require_React().__DEV__ === true) {
          var propTypes = this.constructor.propTypes;
          if (propTypes) {
            this._checkPropTypes(propTypes, props, ReactPropTypeLocations.prop);
          }
        }
        return props;
      },
      /**
       * Assert that the props are valid
       *
       * @param {object} propTypes Map of prop name to a ReactPropType
       * @param {object} props
       * @param {string} location e.g. "prop", "context", "child context"
       * @private
       */
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.constructor.displayName;
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            propTypes[propName](props, propName, componentName, location);
          }
        }
      },
      performUpdateIfNecessary: function() {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
          return;
        }
        ReactComponent.Mixin.performUpdateIfNecessary.call(this);
      },
      /**
       * If any of `_pendingProps`, `_pendingState`, or `_pendingForceUpdate` is
       * set, update the component.
       *
       * @param {ReactReconcileTransaction} transaction
       * @internal
       */
      _performUpdateIfNecessary: function(transaction) {
        if (this._pendingProps == null && this._pendingState == null && this._pendingContext == null && !this._pendingForceUpdate) {
          return;
        }
        var nextFullContext = this._pendingContext || this._currentContext;
        var nextContext = this._processContext(nextFullContext);
        this._pendingContext = null;
        var nextProps = this.props;
        if (this._pendingProps != null) {
          nextProps = this._processProps(this._pendingProps);
          this._pendingProps = null;
          this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
          if (this.componentWillReceiveProps) {
            this.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_STATE;
        var nextOwner = this._pendingOwner;
        var nextState = this._pendingState || this.state;
        this._pendingState = null;
        try {
          if (this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext)) {
            this._pendingForceUpdate = false;
            this._performComponentUpdate(
              nextProps,
              nextOwner,
              nextState,
              nextFullContext,
              nextContext,
              transaction
            );
          } else {
            this.props = nextProps;
            this._owner = nextOwner;
            this.state = nextState;
            this._currentContext = nextFullContext;
            this.context = nextContext;
          }
        } finally {
          this._compositeLifeCycleState = null;
        }
      },
      /**
       * Merges new props and state, notifies delegate methods of update and
       * performs update.
       *
       * @param {object} nextProps Next object to set as properties.
       * @param {?ReactComponent} nextOwner Next component to set as owner
       * @param {?object} nextState Next object to set as state.
       * @param {?object} nextFullContext Next object to set as _currentContext.
       * @param {?object} nextContext Next object to set as context.
       * @param {ReactReconcileTransaction} transaction
       * @private
       */
      _performComponentUpdate: function(nextProps, nextOwner, nextState, nextFullContext, nextContext, transaction) {
        var prevProps = this.props;
        var prevOwner = this._owner;
        var prevState = this.state;
        var prevContext = this.context;
        if (this.componentWillUpdate) {
          this.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this.props = nextProps;
        this._owner = nextOwner;
        this.state = nextState;
        this._currentContext = nextFullContext;
        this.context = nextContext;
        this.updateComponent(
          transaction,
          prevProps,
          prevOwner,
          prevState,
          prevContext
        );
        if (this.componentDidUpdate) {
          transaction.getReactMountReady().enqueue(
            this,
            this.componentDidUpdate.bind(this, prevProps, prevState, prevContext)
          );
        }
      },
      receiveComponent: function(nextComponent, transaction) {
        if (nextComponent === this._descriptor) {
          return;
        }
        this._descriptor = nextComponent;
        this._pendingContext = nextComponent._currentContext;
        ReactComponent.Mixin.receiveComponent.call(
          this,
          nextComponent,
          transaction
        );
      },
      /**
       * Updates the component's currently mounted DOM representation.
       *
       * By default, this implements React's rendering and reconciliation algorithm.
       * Sophisticated clients may wish to override this.
       *
       * @param {ReactReconcileTransaction} transaction
       * @param {object} prevProps
       * @param {?ReactComponent} prevOwner
       * @param {?object} prevState
       * @param {?object} prevContext
       * @internal
       * @overridable
       */
      updateComponent: ReactPerf.measure(
        "ReactCompositeComponent",
        "updateComponent",
        function(transaction, prevProps, prevOwner, prevState, prevContext) {
          ReactComponent.Mixin.updateComponent.call(
            this,
            transaction,
            prevProps,
            prevOwner
          );
          var prevComponentInstance = this._renderedComponent;
          var nextComponent = this._renderValidatedComponent();
          if (shouldUpdateReactComponent(prevComponentInstance, nextComponent)) {
            prevComponentInstance.receiveComponent(nextComponent, transaction);
          } else {
            var thisID = this._rootNodeID;
            var prevComponentID = prevComponentInstance._rootNodeID;
            prevComponentInstance.unmountComponent();
            this._renderedComponent = instantiateReactComponent(nextComponent);
            var nextMarkup = this._renderedComponent.mountComponent(
              thisID,
              transaction,
              this._mountDepth + 1
            );
            ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(
              prevComponentID,
              nextMarkup
            );
          }
        }
      ),
      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldUpdateComponent`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {?function} callback Called after update is complete.
       * @final
       * @protected
       */
      forceUpdate: function(callback) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        require_React().__DEV__ === true ? invariant(
          this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
          "forceUpdate(...): Can only force an update on mounted or mounting components."
        ) : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);
        require_React().__DEV__ === true ? invariant(
          compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE && compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
          "forceUpdate(...): Cannot force an update while unmounting component or during an existing state transition (such as within `render`)."
        ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE && compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING);
        this._pendingForceUpdate = true;
        ReactUpdates.enqueueUpdate(this, callback);
      },
      /**
       * @private
       */
      _renderValidatedComponent: ReactPerf.measure(
        "ReactCompositeComponent",
        "_renderValidatedComponent",
        function() {
          var renderedComponent;
          var previousContext = ReactContext.current;
          ReactContext.current = this._processChildContext(this._currentContext);
          ReactCurrentOwner.current = this;
          try {
            renderedComponent = this.render();
          } finally {
            ReactContext.current = previousContext;
            ReactCurrentOwner.current = null;
          }
          require_React().__DEV__ === true ? invariant(
            ReactComponent.isValidComponent(renderedComponent),
            "%s.render(): A valid ReactComponent must be returned. You may have returned null, undefined, an array, or some other invalid object.",
            this.constructor.displayName || "ReactCompositeComponent"
          ) : invariant(ReactComponent.isValidComponent(renderedComponent));
          return renderedComponent;
        }
      ),
      /**
       * @private
       */
      _bindAutoBindMethods: function() {
        for (var autoBindKey in this.__reactAutoBindMap) {
          if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
            continue;
          }
          var method = this.__reactAutoBindMap[autoBindKey];
          this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(
            method,
            this.constructor.displayName + "." + autoBindKey
          ));
        }
      },
      /**
       * Binds a method to the component.
       *
       * @param {function} method Method to be bound.
       * @private
       */
      _bindAutoBindMethod: function(method) {
        var component = this;
        var boundMethod = function() {
          return method.apply(component, arguments);
        };
        if (require_React().__DEV__ === true) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (newThis !== component && newThis !== null) {
              monitorCodeUse("react_bind_warning", { component: componentName });
              console.warn(
                "bind(): React component methods may only be bound to the component instance. See " + componentName
              );
            } else if (!args.length) {
              monitorCodeUse("react_bind_warning", { component: componentName });
              console.warn(
                "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See " + componentName
              );
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
    };
    var ReactCompositeComponentBase = function() {
    };
    mixInto(ReactCompositeComponentBase, ReactComponent.Mixin);
    mixInto(ReactCompositeComponentBase, ReactOwner.Mixin);
    mixInto(ReactCompositeComponentBase, ReactPropTransferer.Mixin);
    mixInto(ReactCompositeComponentBase, ReactCompositeComponentMixin);
    function isValidClass(componentClass) {
      return componentClass instanceof Function && "componentConstructor" in componentClass && componentClass.componentConstructor instanceof Function;
    }
    var ReactCompositeComponent = {
      LifeCycle: CompositeLifeCycle,
      Base: ReactCompositeComponentBase,
      /**
       * Creates a composite component class given a class specification.
       *
       * @param {object} spec Class specification (which must define `render`).
       * @return {function} Component constructor function.
       * @public
       */
      createClass: function(spec) {
        var Constructor = function() {
        };
        Constructor.prototype = new ReactCompositeComponentBase();
        Constructor.prototype.constructor = Constructor;
        var DescriptorConstructor = Constructor;
        var ConvenienceConstructor = function(props, children) {
          var descriptor = new DescriptorConstructor();
          descriptor.construct.apply(descriptor, arguments);
          return descriptor;
        };
        ConvenienceConstructor.componentConstructor = Constructor;
        Constructor.ConvenienceConstructor = ConvenienceConstructor;
        ConvenienceConstructor.originalSpec = spec;
        injectedMixins.forEach(
          mixSpecIntoComponent.bind(null, ConvenienceConstructor)
        );
        mixSpecIntoComponent(ConvenienceConstructor, spec);
        require_React().__DEV__ === true ? invariant(
          Constructor.prototype.render,
          "createClass(...): Class specification must implement a `render` method."
        ) : invariant(Constructor.prototype.render);
        if (require_React().__DEV__ === true) {
          if (Constructor.prototype.componentShouldUpdate) {
            monitorCodeUse(
              "react_component_should_update_warning",
              { component: spec.displayName }
            );
            console.warn(
              (spec.displayName || "A component") + " has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value."
            );
          }
        }
        ConvenienceConstructor.type = Constructor;
        Constructor.prototype.type = Constructor;
        for (var methodName in ReactCompositeComponentInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        if (require_React().__DEV__ === true) {
          DescriptorConstructor = createDescriptorProxy(Constructor);
        }
        return ConvenienceConstructor;
      },
      isValidClass,
      injection: {
        injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }
      }
    };
    module.exports = ReactCompositeComponent;
  }
});

// node_modules/react-component/lib/CSSProperty.js
var require_CSSProperty = __commonJS({
  "node_modules/react-component/lib/CSSProperty.js"(exports, module) {
    "use strict";
    var isUnitlessNumber = {
      columnCount: true,
      fillOpacity: true,
      flex: true,
      flexGrow: true,
      flexShrink: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      widows: true,
      zIndex: true,
      zoom: true
    };
    function prefixKey(prefix, key) {
      return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    var prefixes = ["Webkit", "ms", "Moz", "O"];
    Object.keys(isUnitlessNumber).forEach(function(prop) {
      prefixes.forEach(function(prefix) {
        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
      });
    });
    var shorthandPropertyExpansions = {
      background: {
        backgroundImage: true,
        backgroundPosition: true,
        backgroundRepeat: true,
        backgroundColor: true
      },
      border: {
        borderWidth: true,
        borderStyle: true,
        borderColor: true
      },
      borderBottom: {
        borderBottomWidth: true,
        borderBottomStyle: true,
        borderBottomColor: true
      },
      borderLeft: {
        borderLeftWidth: true,
        borderLeftStyle: true,
        borderLeftColor: true
      },
      borderRight: {
        borderRightWidth: true,
        borderRightStyle: true,
        borderRightColor: true
      },
      borderTop: {
        borderTopWidth: true,
        borderTopStyle: true,
        borderTopColor: true
      },
      font: {
        fontStyle: true,
        fontVariant: true,
        fontWeight: true,
        fontSize: true,
        lineHeight: true,
        fontFamily: true
      }
    };
    var CSSProperty = {
      isUnitlessNumber,
      shorthandPropertyExpansions
    };
    module.exports = CSSProperty;
  }
});

// node_modules/react-component/lib/dangerousStyleValue.js
var require_dangerousStyleValue = __commonJS({
  "node_modules/react-component/lib/dangerousStyleValue.js"(exports, module) {
    "use strict";
    var CSSProperty = require_CSSProperty();
    function dangerousStyleValue(styleName, value) {
      var isEmpty = value == null || typeof value === "boolean" || value === "";
      if (isEmpty) {
        return "";
      }
      var isNonNumeric = isNaN(value);
      if (isNonNumeric || value === 0 || CSSProperty.isUnitlessNumber[styleName]) {
        return "" + value;
      }
      return value + "px";
    }
    module.exports = dangerousStyleValue;
  }
});

// node_modules/react-component/lib/hyphenate.js
var require_hyphenate = __commonJS({
  "node_modules/react-component/lib/hyphenate.js"(exports, module) {
    var _uppercasePattern = /([A-Z])/g;
    function hyphenate(string) {
      return string.replace(_uppercasePattern, "-$1").toLowerCase();
    }
    module.exports = hyphenate;
  }
});

// node_modules/react-component/lib/CSSPropertyOperations.js
var require_CSSPropertyOperations = __commonJS({
  "node_modules/react-component/lib/CSSPropertyOperations.js"(exports, module) {
    "use strict";
    var CSSProperty = require_CSSProperty();
    var dangerousStyleValue = require_dangerousStyleValue();
    var escapeTextForBrowser = require_escapeTextForBrowser();
    var hyphenate = require_hyphenate();
    var memoizeStringOnly = require_memoizeStringOnly();
    var processStyleName = memoizeStringOnly(function(styleName) {
      return escapeTextForBrowser(hyphenate(styleName));
    });
    var CSSPropertyOperations = {
      /**
       * Serializes a mapping of style properties for use as inline styles:
       *
       *   > createMarkupForStyles({width: '200px', height: 0})
       *   "width:200px;height:0;"
       *
       * Undefined values are ignored so that declarative programming is easier.
       *
       * @param {object} styles
       * @return {?string}
       */
      createMarkupForStyles: function(styles) {
        var serialized = "";
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = styles[styleName];
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ":";
            serialized += dangerousStyleValue(styleName, styleValue) + ";";
          }
        }
        return serialized || null;
      },
      /**
       * Sets the value for multiple styles on a node.  If a value is specified as
       * '' (empty string), the corresponding style property will be unset.
       *
       * @param {DOMElement} node
       * @param {object} styles
       */
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = "";
              }
            } else {
              style[styleName] = "";
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  }
});

// node_modules/react-component/lib/ReactMultiChildUpdateTypes.js
var require_ReactMultiChildUpdateTypes = __commonJS({
  "node_modules/react-component/lib/ReactMultiChildUpdateTypes.js"(exports, module) {
    "use strict";
    var keyMirror = require_keyMirror();
    var ReactMultiChildUpdateTypes = keyMirror({
      INSERT_MARKUP: null,
      MOVE_EXISTING: null,
      REMOVE_NODE: null,
      TEXT_CONTENT: null
    });
    module.exports = ReactMultiChildUpdateTypes;
  }
});

// node_modules/react-component/lib/flattenChildren.js
var require_flattenChildren = __commonJS({
  "node_modules/react-component/lib/flattenChildren.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var traverseAllChildren = require_traverseAllChildren();
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      require_React().__DEV__ === true ? invariant(
        !result.hasOwnProperty(name),
        "flattenChildren(...): Encountered two children with the same key, `%s`. Children keys must be unique.",
        name
      ) : invariant(!result.hasOwnProperty(name));
      if (child != null) {
        result[name] = child;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  }
});

// node_modules/react-component/lib/ReactMultiChild.js
var require_ReactMultiChild = __commonJS({
  "node_modules/react-component/lib/ReactMultiChild.js"(exports, module) {
    "use strict";
    var ReactComponent = require_ReactComponent();
    var ReactMultiChildUpdateTypes = require_ReactMultiChildUpdateTypes();
    var flattenChildren = require_flattenChildren();
    var instantiateReactComponent = require_instantiateReactComponent();
    var shouldUpdateReactComponent = require_shouldUpdateReactComponent();
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        textContent: null,
        fromIndex: null,
        toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        textContent: null,
        fromIndex,
        toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        textContent: null,
        fromIndex,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(
          updateQueue,
          markupQueue
        );
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {
      /**
       * Provides common functionality for components that must reconcile multiple
       * children. This is used by `ReactDOMComponent` to mount, update, and
       * unmount child components.
       *
       * @lends {ReactMultiChild.prototype}
       */
      Mixin: {
        /**
         * Generates a "mount image" for each of the supplied children. In the case
         * of `ReactDOMComponent`, a mount image is a string of markup.
         *
         * @param {?object} nestedChildren Nested child maps.
         * @return {array} An array of mounted representations.
         * @internal
         */
        mountChildren: function(nestedChildren, transaction) {
          var children = flattenChildren(nestedChildren);
          var mountImages = [];
          var index = 0;
          this._renderedChildren = children;
          for (var name in children) {
            var child = children[name];
            if (children.hasOwnProperty(name)) {
              var childInstance = instantiateReactComponent(child);
              children[name] = childInstance;
              var rootID = this._rootNodeID + name;
              var mountImage = childInstance.mountComponent(
                rootID,
                transaction,
                this._mountDepth + 1
              );
              childInstance._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        /**
         * Replaces any rendered children with a text content string.
         *
         * @param {string} nextContent String of content.
         * @internal
         */
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        /**
         * Updates the rendered children with new children.
         *
         * @param {?object} nextNestedChildren Nested child maps.
         * @param {ReactReconcileTransaction} transaction
         * @internal
         */
        updateChildren: function(nextNestedChildren, transaction) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildren, transaction);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        /**
         * Improve performance by isolating this hot code path from the try/catch
         * block in `updateChildren`.
         *
         * @param {?object} nextNestedChildren Nested child maps.
         * @param {ReactReconcileTransaction} transaction
         * @final
         * @protected
         */
        _updateChildren: function(nextNestedChildren, transaction) {
          var nextChildren = flattenChildren(nextNestedChildren);
          var prevChildren = this._renderedChildren;
          if (!nextChildren && !prevChildren) {
            return;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (shouldUpdateReactComponent(prevChild, nextChild)) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild.receiveComponent(nextChild, transaction);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChildByName(prevChild, name);
              }
              var nextChildInstance = instantiateReactComponent(nextChild);
              this._mountChildByNameAtIndex(
                nextChildInstance,
                name,
                nextIndex,
                transaction
              );
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren[name])) {
              this._unmountChildByName(prevChildren[name], name);
            }
          }
        },
        /**
         * Unmounts all rendered children. This should be used to clean up children
         * when this component is unmounted.
         *
         * @internal
         */
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            if (renderedChild.unmountComponent) {
              renderedChild.unmountComponent();
            }
          }
          this._renderedChildren = null;
        },
        /**
         * Moves a child component to the supplied index.
         *
         * @param {ReactComponent} child Component to move.
         * @param {number} toIndex Destination index of the element.
         * @param {number} lastIndex Last index visited of the siblings of `child`.
         * @protected
         */
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        /**
         * Creates a child component.
         *
         * @param {ReactComponent} child Component to create.
         * @param {string} mountImage Markup to insert.
         * @protected
         */
        createChild: function(child, mountImage) {
          enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        /**
         * Removes a child component.
         *
         * @param {ReactComponent} child Child to remove.
         * @protected
         */
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        /**
         * Sets this text content string.
         *
         * @param {string} textContent Text content to set.
         * @protected
         */
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        /**
         * Mounts a child with the supplied name.
         *
         * NOTE: This is part of `updateChildren` and is here for readability.
         *
         * @param {ReactComponent} child Component to mount.
         * @param {string} name Name of the child.
         * @param {number} index Index at which to insert the child.
         * @param {ReactReconcileTransaction} transaction
         * @private
         */
        _mountChildByNameAtIndex: function(child, name, index, transaction) {
          var rootID = this._rootNodeID + name;
          var mountImage = child.mountComponent(
            rootID,
            transaction,
            this._mountDepth + 1
          );
          child._mountIndex = index;
          this.createChild(child, mountImage);
          this._renderedChildren = this._renderedChildren || {};
          this._renderedChildren[name] = child;
        },
        /**
         * Unmounts a rendered child by name.
         *
         * NOTE: This is part of `updateChildren` and is here for readability.
         *
         * @param {ReactComponent} child Component to unmount.
         * @param {string} name Name of the child in `this._renderedChildren`.
         * @private
         */
        _unmountChildByName: function(child, name) {
          if (ReactComponent.isValidComponent(child)) {
            this.removeChild(child);
            child._mountIndex = null;
            child.unmountComponent();
            delete this._renderedChildren[name];
          }
        }
      }
    };
    module.exports = ReactMultiChild;
  }
});

// node_modules/react-component/lib/keyOf.js
var require_keyOf = __commonJS({
  "node_modules/react-component/lib/keyOf.js"(exports, module) {
    var keyOf = function(oneKeyObj) {
      var key;
      for (key in oneKeyObj) {
        if (!oneKeyObj.hasOwnProperty(key)) {
          continue;
        }
        return key;
      }
      return null;
    };
    module.exports = keyOf;
  }
});

// node_modules/react-component/lib/ReactDOMComponent.js
var require_ReactDOMComponent = __commonJS({
  "node_modules/react-component/lib/ReactDOMComponent.js"(exports, module) {
    "use strict";
    var CSSPropertyOperations = require_CSSPropertyOperations();
    var DOMProperty = require_DOMProperty();
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactComponent = require_ReactComponent();
    var ReactEventEmitter = require_ReactEventEmitter();
    var ReactMount = require_ReactMount();
    var ReactMultiChild = require_ReactMultiChild();
    var ReactPerf = require_ReactPerf();
    var escapeTextForBrowser = require_escapeTextForBrowser();
    var invariant = require_invariant();
    var keyOf = require_keyOf();
    var merge = require_merge();
    var mixInto = require_mixInto();
    var deleteListener = ReactEventEmitter.deleteListener;
    var listenTo = ReactEventEmitter.listenTo;
    var registrationNameModules = ReactEventEmitter.registrationNameModules;
    var CONTENT_TYPES = { "string": true, "number": true };
    var STYLE = keyOf({ style: null });
    var ELEMENT_NODE_TYPE = 1;
    function assertValidProps(props) {
      if (!props) {
        return;
      }
      require_React().__DEV__ === true ? invariant(
        props.children == null || props.dangerouslySetInnerHTML == null,
        "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
      ) : invariant(props.children == null || props.dangerouslySetInnerHTML == null);
      require_React().__DEV__ === true ? invariant(
        props.style == null || typeof props.style === "object",
        "The `style` prop expects a mapping from style properties to values, not a string."
      ) : invariant(props.style == null || typeof props.style === "object");
    }
    function putListener(id, registrationName, listener, transaction) {
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getPutListenerQueue().enqueuePutListener(
        id,
        registrationName,
        listener
      );
    }
    function ReactDOMComponent(tag, omitClose) {
      this._tagOpen = "<" + tag;
      this._tagClose = omitClose ? "" : "</" + tag + ">";
      this.tagName = tag.toUpperCase();
    }
    ReactDOMComponent.Mixin = {
      /**
       * Generates root tag markup then recurses. This method has side effects and
       * is not idempotent.
       *
       * @internal
       * @param {string} rootID The root DOM ID for this node.
       * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
       * @param {number} mountDepth number of components in the owner hierarchy
       * @return {string} The computed markup.
       */
      mountComponent: ReactPerf.measure(
        "ReactDOMComponent",
        "mountComponent",
        function(rootID, transaction, mountDepth) {
          ReactComponent.Mixin.mountComponent.call(
            this,
            rootID,
            transaction,
            mountDepth
          );
          assertValidProps(this.props);
          return this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction) + this._tagClose;
        }
      ),
      /**
       * Creates markup for the open tag and all attributes.
       *
       * This method has side effects because events get registered.
       *
       * Iterating over object properties is faster than iterating over arrays.
       * @see http://jsperf.com/obj-vs-arr-iteration
       *
       * @private
       * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
       * @return {string} Markup of opening tag.
       */
      _createOpenTagMarkupAndPutListeners: function(transaction) {
        var props = this.props;
        var ret = this._tagOpen;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules[propKey]) {
            putListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                propValue = props.style = merge(props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            if (markup) {
              ret += " " + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret + ">";
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + " " + markupForID + ">";
      },
      /**
       * Creates markup for the content between the tags.
       *
       * @private
       * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
       * @return {string} Content markup.
       */
      _createContentMarkup: function(transaction) {
        var innerHTML = this.props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            return innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
          var childrenToUse = contentToUse != null ? null : this.props.children;
          if (contentToUse != null) {
            return escapeTextForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(
              childrenToUse,
              transaction
            );
            return mountImages.join("");
          }
        }
        return "";
      },
      receiveComponent: function(nextComponent, transaction) {
        if (nextComponent === this) {
          return;
        }
        assertValidProps(nextComponent.props);
        ReactComponent.Mixin.receiveComponent.call(
          this,
          nextComponent,
          transaction
        );
      },
      /**
       * Updates a native DOM component after it has already been allocated and
       * attached to the DOM. Reconciles the root DOM node, then recurses.
       *
       * @param {ReactReconcileTransaction} transaction
       * @param {object} prevProps
       * @internal
       * @overridable
       */
      updateComponent: ReactPerf.measure(
        "ReactDOMComponent",
        "updateComponent",
        function(transaction, prevProps, prevOwner) {
          ReactComponent.Mixin.updateComponent.call(
            this,
            transaction,
            prevProps,
            prevOwner
          );
          this._updateDOMProperties(prevProps, transaction);
          this._updateDOMChildren(prevProps, transaction);
        }
      ),
      /**
       * Reconciles the properties by detecting differences in property values and
       * updating the DOM as necessary. This function is probably the single most
       * critical path for performance optimization.
       *
       * TODO: Benchmark whether checking for changed values in memory actually
       *       improves performance (especially statically positioned elements).
       * TODO: Benchmark the effects of putting this at the top since 99% of props
       *       do not change for a given reconciliation.
       * TODO: Benchmark areas that can be improved with caching.
       *
       * @private
       * @param {object} lastProps
       * @param {ReactReconcileTransaction} transaction
       */
      _updateDOMProperties: function(lastProps, transaction) {
        var nextProps = this.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = "";
              }
            }
          } else if (registrationNameModules[propKey]) {
            deleteListener(this._rootNodeID, propKey);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.deletePropertyByID(
              this._rootNodeID,
              propKey
            );
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              nextProp = nextProps.style = merge(nextProp);
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && !nextProp.hasOwnProperty(styleName)) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules[propKey]) {
            putListener(this._rootNodeID, propKey, nextProp, transaction);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.updatePropertyByID(
              this._rootNodeID,
              propKey,
              nextProp
            );
          }
        }
        if (styleUpdates) {
          ReactComponent.BackendIDOperations.updateStylesByID(
            this._rootNodeID,
            styleUpdates
          );
        }
      },
      /**
       * Reconciles the children with the various properties that affect the
       * children content.
       *
       * @param {object} lastProps
       * @param {ReactReconcileTransaction} transaction
       */
      _updateDOMChildren: function(lastProps, transaction) {
        var nextProps = this.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent("");
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent("" + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            ReactComponent.BackendIDOperations.updateInnerHTMLByID(
              this._rootNodeID,
              nextHtml
            );
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction);
        }
      },
      /**
       * Destroys all event registrations for this instance. Does not remove from
       * the DOM. That must be done by the parent.
       *
       * @internal
       */
      unmountComponent: function() {
        this.unmountChildren();
        ReactEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponent.Mixin.unmountComponent.call(this);
      }
    };
    mixInto(ReactDOMComponent, ReactComponent.Mixin);
    mixInto(ReactDOMComponent, ReactDOMComponent.Mixin);
    mixInto(ReactDOMComponent, ReactMultiChild.Mixin);
    mixInto(ReactDOMComponent, ReactBrowserComponentMixin);
    module.exports = ReactDOMComponent;
  }
});

// node_modules/react-component/lib/objMapKeyVal.js
var require_objMapKeyVal = __commonJS({
  "node_modules/react-component/lib/objMapKeyVal.js"(exports, module) {
    "use strict";
    function objMapKeyVal(obj, func, context) {
      if (!obj) {
        return null;
      }
      var i = 0;
      var ret = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = func.call(context, key, obj[key], i++);
        }
      }
      return ret;
    }
    module.exports = objMapKeyVal;
  }
});

// node_modules/react-component/lib/ReactDOM.js
var require_ReactDOM = __commonJS({
  "node_modules/react-component/lib/ReactDOM.js"(exports, module) {
    "use strict";
    var ReactDOMComponent = require_ReactDOMComponent();
    var mergeInto = require_mergeInto();
    var objMapKeyVal = require_objMapKeyVal();
    function createDOMComponentClass(tag, omitClose) {
      var Constructor = function() {
      };
      Constructor.prototype = new ReactDOMComponent(tag, omitClose);
      Constructor.prototype.constructor = Constructor;
      Constructor.displayName = tag;
      var ConvenienceConstructor = function(props, children) {
        var instance = new Constructor();
        instance.construct.apply(instance, arguments);
        return instance;
      };
      ConvenienceConstructor.type = Constructor;
      Constructor.prototype.type = Constructor;
      Constructor.ConvenienceConstructor = ConvenienceConstructor;
      ConvenienceConstructor.componentConstructor = Constructor;
      return ConvenienceConstructor;
    }
    var ReactDOM = objMapKeyVal({
      a: false,
      abbr: false,
      address: false,
      area: true,
      article: false,
      aside: false,
      audio: false,
      b: false,
      base: true,
      bdi: false,
      bdo: false,
      big: false,
      blockquote: false,
      body: false,
      br: true,
      button: false,
      canvas: false,
      caption: false,
      cite: false,
      code: false,
      col: true,
      colgroup: false,
      data: false,
      datalist: false,
      dd: false,
      del: false,
      details: false,
      dfn: false,
      div: false,
      dl: false,
      dt: false,
      em: false,
      embed: true,
      fieldset: false,
      figcaption: false,
      figure: false,
      footer: false,
      form: false,
      // NOTE: Injected, see `ReactDOMForm`.
      h1: false,
      h2: false,
      h3: false,
      h4: false,
      h5: false,
      h6: false,
      head: false,
      header: false,
      hr: true,
      html: false,
      i: false,
      iframe: false,
      img: true,
      input: true,
      ins: false,
      kbd: false,
      keygen: true,
      label: false,
      legend: false,
      li: false,
      link: true,
      main: false,
      map: false,
      mark: false,
      menu: false,
      menuitem: false,
      // NOTE: Close tag should be omitted, but causes problems.
      meta: true,
      meter: false,
      nav: false,
      noscript: false,
      object: false,
      ol: false,
      optgroup: false,
      option: false,
      output: false,
      p: false,
      param: true,
      pre: false,
      progress: false,
      q: false,
      rp: false,
      rt: false,
      ruby: false,
      s: false,
      samp: false,
      script: false,
      section: false,
      select: false,
      small: false,
      source: true,
      span: false,
      strong: false,
      style: false,
      sub: false,
      summary: false,
      sup: false,
      table: false,
      tbody: false,
      td: false,
      textarea: false,
      // NOTE: Injected, see `ReactDOMTextarea`.
      tfoot: false,
      th: false,
      thead: false,
      time: false,
      title: false,
      tr: false,
      track: true,
      u: false,
      ul: false,
      "var": false,
      video: false,
      wbr: true,
      // SVG
      circle: false,
      defs: false,
      g: false,
      line: false,
      linearGradient: false,
      path: false,
      polygon: false,
      polyline: false,
      radialGradient: false,
      rect: false,
      stop: false,
      svg: false,
      text: false
    }, createDOMComponentClass);
    var injection = {
      injectComponentClasses: function(componentClasses) {
        mergeInto(ReactDOM, componentClasses);
      }
    };
    ReactDOM.injection = injection;
    module.exports = ReactDOM;
  }
});

// node_modules/react-component/lib/ReactInjection.js
var require_ReactInjection = __commonJS({
  "node_modules/react-component/lib/ReactInjection.js"(exports, module) {
    "use strict";
    var DOMProperty = require_DOMProperty();
    var EventPluginHub = require_EventPluginHub();
    var ReactComponent = require_ReactComponent();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var ReactEventEmitter = require_ReactEventEmitter();
    var ReactPerf = require_ReactPerf();
    var ReactRootIndex = require_ReactRootIndex();
    var ReactUpdates = require_ReactUpdates();
    var ReactInjection = {
      Component: ReactComponent.injection,
      CompositeComponent: ReactCompositeComponent.injection,
      DOMProperty: DOMProperty.injection,
      EventPluginHub: EventPluginHub.injection,
      DOM: ReactDOM.injection,
      EventEmitter: ReactEventEmitter.injection,
      Perf: ReactPerf.injection,
      RootIndex: ReactRootIndex.injection,
      Updates: ReactUpdates.injection
    };
    module.exports = ReactInjection;
  }
});

// node_modules/react-component/lib/DefaultDOMPropertyConfig.js
var require_DefaultDOMPropertyConfig = __commonJS({
  "node_modules/react-component/lib/DefaultDOMPropertyConfig.js"(exports, module) {
    "use strict";
    var DOMProperty = require_DOMProperty();
    var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
    var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
    var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
    var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
    var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
    var DefaultDOMPropertyConfig = {
      isCustomAttribute: RegExp.prototype.test.bind(
        /^(data|aria)-[a-z_][a-z\d_.\-]*$/
      ),
      Properties: {
        /**
         * Standard Properties
         */
        accept: null,
        accessKey: null,
        action: null,
        allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
        allowTransparency: MUST_USE_ATTRIBUTE,
        alt: null,
        async: HAS_BOOLEAN_VALUE,
        autoComplete: null,
        // autoFocus is polyfilled/normalized by AutoFocusMixin
        // autoFocus: HAS_BOOLEAN_VALUE,
        autoPlay: HAS_BOOLEAN_VALUE,
        cellPadding: null,
        cellSpacing: null,
        charSet: MUST_USE_ATTRIBUTE,
        checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        className: MUST_USE_PROPERTY,
        cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
        colSpan: null,
        content: null,
        contentEditable: null,
        contextMenu: MUST_USE_ATTRIBUTE,
        controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        crossOrigin: null,
        data: null,
        // For `<object />` acts as `src`.
        dateTime: MUST_USE_ATTRIBUTE,
        defer: HAS_BOOLEAN_VALUE,
        dir: null,
        disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
        download: null,
        draggable: null,
        encType: null,
        form: MUST_USE_ATTRIBUTE,
        formNoValidate: HAS_BOOLEAN_VALUE,
        frameBorder: MUST_USE_ATTRIBUTE,
        height: MUST_USE_ATTRIBUTE,
        hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
        href: null,
        hrefLang: null,
        htmlFor: null,
        httpEquiv: null,
        icon: null,
        id: MUST_USE_PROPERTY,
        label: null,
        lang: null,
        list: null,
        loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        max: null,
        maxLength: MUST_USE_ATTRIBUTE,
        mediaGroup: null,
        method: null,
        min: null,
        multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        name: null,
        noValidate: HAS_BOOLEAN_VALUE,
        pattern: null,
        placeholder: null,
        poster: null,
        preload: null,
        radioGroup: null,
        readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        rel: null,
        required: HAS_BOOLEAN_VALUE,
        role: MUST_USE_ATTRIBUTE,
        rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
        rowSpan: null,
        sandbox: null,
        scope: null,
        scrollLeft: MUST_USE_PROPERTY,
        scrollTop: MUST_USE_PROPERTY,
        seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
        selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
        size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
        span: HAS_POSITIVE_NUMERIC_VALUE,
        spellCheck: null,
        src: null,
        srcDoc: MUST_USE_PROPERTY,
        srcSet: null,
        step: null,
        style: null,
        tabIndex: null,
        target: null,
        title: null,
        type: null,
        value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
        width: MUST_USE_ATTRIBUTE,
        wmode: MUST_USE_ATTRIBUTE,
        /**
         * Non-standard Properties
         */
        autoCapitalize: null,
        // Supported in Mobile Safari for keyboard hints
        autoCorrect: null,
        // Supported in Mobile Safari for keyboard hints
        property: null,
        // Supports OG in meta tags
        /**
         * SVG Properties
         */
        cx: MUST_USE_ATTRIBUTE,
        cy: MUST_USE_ATTRIBUTE,
        d: MUST_USE_ATTRIBUTE,
        fill: MUST_USE_ATTRIBUTE,
        fx: MUST_USE_ATTRIBUTE,
        fy: MUST_USE_ATTRIBUTE,
        gradientTransform: MUST_USE_ATTRIBUTE,
        gradientUnits: MUST_USE_ATTRIBUTE,
        offset: MUST_USE_ATTRIBUTE,
        points: MUST_USE_ATTRIBUTE,
        r: MUST_USE_ATTRIBUTE,
        rx: MUST_USE_ATTRIBUTE,
        ry: MUST_USE_ATTRIBUTE,
        spreadMethod: MUST_USE_ATTRIBUTE,
        stopColor: MUST_USE_ATTRIBUTE,
        stopOpacity: MUST_USE_ATTRIBUTE,
        stroke: MUST_USE_ATTRIBUTE,
        strokeLinecap: MUST_USE_ATTRIBUTE,
        strokeWidth: MUST_USE_ATTRIBUTE,
        textAnchor: MUST_USE_ATTRIBUTE,
        transform: MUST_USE_ATTRIBUTE,
        version: MUST_USE_ATTRIBUTE,
        viewBox: MUST_USE_ATTRIBUTE,
        x1: MUST_USE_ATTRIBUTE,
        x2: MUST_USE_ATTRIBUTE,
        x: MUST_USE_ATTRIBUTE,
        y1: MUST_USE_ATTRIBUTE,
        y2: MUST_USE_ATTRIBUTE,
        y: MUST_USE_ATTRIBUTE
      },
      DOMAttributeNames: {
        className: "class",
        gradientTransform: "gradientTransform",
        gradientUnits: "gradientUnits",
        htmlFor: "for",
        spreadMethod: "spreadMethod",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strokeLinecap: "stroke-linecap",
        strokeWidth: "stroke-width",
        textAnchor: "text-anchor",
        viewBox: "viewBox"
      },
      DOMPropertyNames: {
        autoCapitalize: "autocapitalize",
        autoComplete: "autocomplete",
        autoCorrect: "autocorrect",
        autoFocus: "autofocus",
        autoPlay: "autoplay",
        encType: "enctype",
        hrefLang: "hreflang",
        radioGroup: "radiogroup",
        spellCheck: "spellcheck",
        srcDoc: "srcdoc",
        srcSet: "srcset"
      }
    };
    module.exports = DefaultDOMPropertyConfig;
  }
});

// node_modules/react-component/lib/EventPropagators.js
var require_EventPropagators = __commonJS({
  "node_modules/react-component/lib/EventPropagators.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPluginHub = require_EventPluginHub();
    var accumulate = require_accumulate();
    var forEachAccumulated = require_forEachAccumulated();
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if (require_React().__DEV__ === true) {
        if (!domID) {
          throw new Error("Dispatching id must not be null");
        }
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulate(event._dispatchListeners, listener);
        event._dispatchIDs = accumulate(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
          event.dispatchMarker,
          accumulateDirectionalDispatches,
          event
        );
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulate(event._dispatchListeners, listener);
          event._dispatchIDs = accumulate(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
        fromID,
        toID,
        accumulateDispatches,
        leave,
        enter
      );
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches,
      accumulateDirectDispatches,
      accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  }
});

// node_modules/react-component/lib/getEventTarget.js
var require_getEventTarget = __commonJS({
  "node_modules/react-component/lib/getEventTarget.js"(exports, module) {
    "use strict";
    function getEventTarget(nativeEvent) {
      var target = nativeEvent.target || nativeEvent.srcElement || window;
      return target.nodeType === 3 ? target.parentNode : target;
    }
    module.exports = getEventTarget;
  }
});

// node_modules/react-component/lib/SyntheticEvent.js
var require_SyntheticEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticEvent.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var emptyFunction = require_emptyFunction();
    var getEventTarget = require_getEventTarget();
    var merge = require_merge();
    var mergeInto = require_mergeInto();
    var EventInterface = {
      type: null,
      target: getEventTarget,
      // currentTarget is set when dispatching; no use in copying it here
      currentTarget: emptyFunction.thatReturnsNull,
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };
    function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      this.dispatchConfig = dispatchConfig;
      this.dispatchMarker = dispatchMarker;
      this.nativeEvent = nativeEvent;
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          this[propName] = nativeEvent[propName];
        }
      }
      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      } else {
        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    }
    mergeInto(SyntheticEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event.preventDefault ? event.preventDefault() : event.returnValue = false;
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
      },
      /**
       * We release all dispatched `SyntheticEvent`s after each event loop, adding
       * them back into the pool. This allows a way to hold onto a reference that
       * won't be added back into the pool.
       */
      persist: function() {
        this.isPersistent = emptyFunction.thatReturnsTrue;
      },
      /**
       * Checks if this event should be released back into the pool.
       *
       * @return {boolean} True if this should not be released, false otherwise.
       */
      isPersistent: emptyFunction.thatReturnsFalse,
      /**
       * `PooledClass` looks for `destructor` on each instance it releases.
       */
      destructor: function() {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          this[propName] = null;
        }
        this.dispatchConfig = null;
        this.dispatchMarker = null;
        this.nativeEvent = null;
      }
    });
    SyntheticEvent.Interface = EventInterface;
    SyntheticEvent.augmentClass = function(Class, Interface) {
      var Super = this;
      var prototype = Object.create(Super.prototype);
      mergeInto(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = merge(Super.Interface, Interface);
      Class.augmentClass = Super.augmentClass;
      PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
    module.exports = SyntheticEvent;
  }
});

// node_modules/react-component/lib/isTextInputElement.js
var require_isTextInputElement = __commonJS({
  "node_modules/react-component/lib/isTextInputElement.js"(exports, module) {
    "use strict";
    var supportedInputTypes = {
      "color": true,
      "date": true,
      "datetime": true,
      "datetime-local": true,
      "email": true,
      "month": true,
      "number": true,
      "password": true,
      "range": true,
      "search": true,
      "tel": true,
      "text": true,
      "time": true,
      "url": true,
      "week": true
    };
    function isTextInputElement(elem) {
      return elem && (elem.nodeName === "INPUT" && supportedInputTypes[elem.type] || elem.nodeName === "TEXTAREA");
    }
    module.exports = isTextInputElement;
  }
});

// node_modules/react-component/lib/ChangeEventPlugin.js
var require_ChangeEventPlugin = __commonJS({
  "node_modules/react-component/lib/ChangeEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPluginHub = require_EventPluginHub();
    var EventPropagators = require_EventPropagators();
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var ReactUpdates = require_ReactUpdates();
    var SyntheticEvent = require_SyntheticEvent();
    var isEventSupported = require_isEventSupported();
    var isTextInputElement = require_isTextInputElement();
    var keyOf = require_keyOf();
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      change: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onChange: null }),
          captured: keyOf({ onChangeCapture: null })
        },
        dependencies: [
          topLevelTypes.topBlur,
          topLevelTypes.topChange,
          topLevelTypes.topClick,
          topLevelTypes.topFocus,
          topLevelTypes.topInput,
          topLevelTypes.topKeyDown,
          topLevelTypes.topKeyUp,
          topLevelTypes.topSelectionChange
        ]
      }
    };
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      return elem.nodeName === "SELECT" || elem.nodeName === "INPUT" && elem.type === "file";
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported("change") && (!("documentMode" in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(
        eventTypes.change,
        activeElementID,
        nativeEvent
      );
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent("onchange", manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent("onchange", manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported("input") && (!("documentMode" in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = "" + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(
        target.constructor.prototype,
        "value"
      );
      Object.defineProperty(activeElement, "value", newValueProp);
      activeElement.attachEvent("onpropertychange", handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      delete activeElement.value;
      activeElement.detachEvent("onpropertychange", handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== "value") {
        return;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return elem.nodeName === "INPUT" && (elem.type === "checkbox" || elem.type === "radio");
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes,
      /**
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc, handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(
            topLevelType,
            topLevelTarget,
            topLevelTargetID
          );
          if (targetID) {
            var event = SyntheticEvent.getPooled(
              eventTypes.change,
              targetID,
              nativeEvent
            );
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(
            topLevelType,
            topLevelTarget,
            topLevelTargetID
          );
        }
      }
    };
    module.exports = ChangeEventPlugin;
  }
});

// node_modules/react-component/lib/ClientReactRootIndex.js
var require_ClientReactRootIndex = __commonJS({
  "node_modules/react-component/lib/ClientReactRootIndex.js"(exports, module) {
    "use strict";
    var nextReactRootIndex = 0;
    var ClientReactRootIndex = {
      createReactRootIndex: function() {
        return nextReactRootIndex++;
      }
    };
    module.exports = ClientReactRootIndex;
  }
});

// node_modules/react-component/lib/getNodeForCharacterOffset.js
var require_getNodeForCharacterOffset = __commonJS({
  "node_modules/react-component/lib/getNodeForCharacterOffset.js"(exports, module) {
    "use strict";
    function getLeafNode(node) {
      while (node && node.firstChild) {
        node = node.firstChild;
      }
      return node;
    }
    function getSiblingNode(node) {
      while (node) {
        if (node.nextSibling) {
          return node.nextSibling;
        }
        node = node.parentNode;
      }
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      var nodeStart = 0;
      var nodeEnd = 0;
      while (node) {
        if (node.nodeType == 3) {
          nodeEnd = nodeStart + node.textContent.length;
          if (nodeStart <= offset && nodeEnd >= offset) {
            return {
              node,
              offset: offset - nodeStart
            };
          }
          nodeStart = nodeEnd;
        }
        node = getLeafNode(getSiblingNode(node));
      }
    }
    module.exports = getNodeForCharacterOffset;
  }
});

// node_modules/react-component/lib/getTextContentAccessor.js
var require_getTextContentAccessor = __commonJS({
  "node_modules/react-component/lib/getTextContentAccessor.js"(exports, module) {
    "use strict";
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var contentKey = null;
    function getTextContentAccessor() {
      if (!contentKey && ExecutionEnvironment.canUseDOM) {
        contentKey = "textContent" in document.createElement("div") ? "textContent" : "innerText";
      }
      return contentKey;
    }
    module.exports = getTextContentAccessor;
  }
});

// node_modules/react-component/lib/ReactDOMSelection.js
var require_ReactDOMSelection = __commonJS({
  "node_modules/react-component/lib/ReactDOMSelection.js"(exports, module) {
    "use strict";
    var getNodeForCharacterOffset = require_getNodeForCharacterOffset();
    var getTextContentAccessor = require_getTextContentAccessor();
    function getIEOffsets(node) {
      var selection = document.selection;
      var selectedRange = selection.createRange();
      var selectedLength = selectedRange.text.length;
      var fromStart = selectedRange.duplicate();
      fromStart.moveToElementText(node);
      fromStart.setEndPoint("EndToStart", selectedRange);
      var startOffset = fromStart.text.length;
      var endOffset = startOffset + selectedLength;
      return {
        start: startOffset,
        end: endOffset
      };
    }
    function getModernOffsets(node) {
      var selection = window.getSelection();
      if (selection.rangeCount === 0) {
        return null;
      }
      var anchorNode = selection.anchorNode;
      var anchorOffset = selection.anchorOffset;
      var focusNode = selection.focusNode;
      var focusOffset = selection.focusOffset;
      var currentRange = selection.getRangeAt(0);
      var rangeLength = currentRange.toString().length;
      var tempRange = currentRange.cloneRange();
      tempRange.selectNodeContents(node);
      tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
      var start = tempRange.toString().length;
      var end = start + rangeLength;
      var detectionRange = document.createRange();
      detectionRange.setStart(anchorNode, anchorOffset);
      detectionRange.setEnd(focusNode, focusOffset);
      var isBackward = detectionRange.collapsed;
      detectionRange.detach();
      return {
        start: isBackward ? end : start,
        end: isBackward ? start : end
      };
    }
    function setIEOffsets(node, offsets) {
      var range = document.selection.createRange().duplicate();
      var start, end;
      if (typeof offsets.end === "undefined") {
        start = offsets.start;
        end = start;
      } else if (offsets.start > offsets.end) {
        start = offsets.end;
        end = offsets.start;
      } else {
        start = offsets.start;
        end = offsets.end;
      }
      range.moveToElementText(node);
      range.moveStart("character", start);
      range.setEndPoint("EndToStart", range);
      range.moveEnd("character", end - start);
      range.select();
    }
    function setModernOffsets(node, offsets) {
      var selection = window.getSelection();
      var length = node[getTextContentAccessor()].length;
      var start = Math.min(offsets.start, length);
      var end = typeof offsets.end === "undefined" ? start : Math.min(offsets.end, length);
      if (!selection.extend && start > end) {
        var temp = end;
        end = start;
        start = temp;
      }
      var startMarker = getNodeForCharacterOffset(node, start);
      var endMarker = getNodeForCharacterOffset(node, end);
      if (startMarker && endMarker) {
        var range = document.createRange();
        range.setStart(startMarker.node, startMarker.offset);
        selection.removeAllRanges();
        if (start > end) {
          selection.addRange(range);
          selection.extend(endMarker.node, endMarker.offset);
        } else {
          range.setEnd(endMarker.node, endMarker.offset);
          selection.addRange(range);
        }
        range.detach();
      }
    }
    var ReactDOMSelection = {
      /**
       * @param {DOMElement} node
       */
      getOffsets: function(node) {
        var getOffsets = document.selection ? getIEOffsets : getModernOffsets;
        return getOffsets(node);
      },
      /**
       * @param {DOMElement|DOMTextNode} node
       * @param {object} offsets
       */
      setOffsets: function(node, offsets) {
        var setOffsets = document.selection ? setIEOffsets : setModernOffsets;
        setOffsets(node, offsets);
      }
    };
    module.exports = ReactDOMSelection;
  }
});

// node_modules/react-component/lib/focusNode.js
var require_focusNode = __commonJS({
  "node_modules/react-component/lib/focusNode.js"(exports, module) {
    "use strict";
    function focusNode(node) {
      if (!node.disabled) {
        node.focus();
      }
    }
    module.exports = focusNode;
  }
});

// node_modules/react-component/lib/getActiveElement.js
var require_getActiveElement = __commonJS({
  "node_modules/react-component/lib/getActiveElement.js"(exports, module) {
    function getActiveElement() {
      try {
        return document.activeElement || document.body;
      } catch (e) {
        return document.body;
      }
    }
    module.exports = getActiveElement;
  }
});

// node_modules/react-component/lib/ReactInputSelection.js
var require_ReactInputSelection = __commonJS({
  "node_modules/react-component/lib/ReactInputSelection.js"(exports, module) {
    "use strict";
    var ReactDOMSelection = require_ReactDOMSelection();
    var containsNode = require_containsNode();
    var focusNode = require_focusNode();
    var getActiveElement = require_getActiveElement();
    function isInDocument(node) {
      return containsNode(document.documentElement, node);
    }
    var ReactInputSelection = {
      hasSelectionCapabilities: function(elem) {
        return elem && (elem.nodeName === "INPUT" && elem.type === "text" || elem.nodeName === "TEXTAREA" || elem.contentEditable === "true");
      },
      getSelectionInformation: function() {
        var focusedElem = getActiveElement();
        return {
          focusedElem,
          selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
        };
      },
      /**
       * @restoreSelection: If any selection information was potentially lost,
       * restore it. This is useful when performing operations that could remove dom
       * nodes and place them back in, resulting in focus being lost.
       */
      restoreSelection: function(priorSelectionInformation) {
        var curFocusedElem = getActiveElement();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
            ReactInputSelection.setSelection(
              priorFocusedElem,
              priorSelectionRange
            );
          }
          focusNode(priorFocusedElem);
        }
      },
      /**
       * @getSelection: Gets the selection bounds of a focused textarea, input or
       * contentEditable node.
       * -@input: Look up selection bounds of this input
       * -@return {start: selectionStart, end: selectionEnd}
       */
      getSelection: function(input) {
        var selection;
        if ("selectionStart" in input) {
          selection = {
            start: input.selectionStart,
            end: input.selectionEnd
          };
        } else if (document.selection && input.nodeName === "INPUT") {
          var range = document.selection.createRange();
          if (range.parentElement() === input) {
            selection = {
              start: -range.moveStart("character", -input.value.length),
              end: -range.moveEnd("character", -input.value.length)
            };
          }
        } else {
          selection = ReactDOMSelection.getOffsets(input);
        }
        return selection || { start: 0, end: 0 };
      },
      /**
       * @setSelection: Sets the selection bounds of a textarea or input and focuses
       * the input.
       * -@input     Set selection bounds of this input or textarea
       * -@offsets   Object of same form that is returned from get*
       */
      setSelection: function(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (typeof end === "undefined") {
          end = start;
        }
        if ("selectionStart" in input) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        } else if (document.selection && input.nodeName === "INPUT") {
          var range = input.createTextRange();
          range.collapse(true);
          range.moveStart("character", start);
          range.moveEnd("character", end - start);
          range.select();
        } else {
          ReactDOMSelection.setOffsets(input, offsets);
        }
      }
    };
    module.exports = ReactInputSelection;
  }
});

// node_modules/react-component/lib/SyntheticCompositionEvent.js
var require_SyntheticCompositionEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticCompositionEvent.js"(exports, module) {
    "use strict";
    var SyntheticEvent = require_SyntheticEvent();
    var CompositionEventInterface = {
      data: null
    };
    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticEvent.augmentClass(
      SyntheticCompositionEvent,
      CompositionEventInterface
    );
    module.exports = SyntheticCompositionEvent;
  }
});

// node_modules/react-component/lib/CompositionEventPlugin.js
var require_CompositionEventPlugin = __commonJS({
  "node_modules/react-component/lib/CompositionEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPropagators = require_EventPropagators();
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var ReactInputSelection = require_ReactInputSelection();
    var SyntheticCompositionEvent = require_SyntheticCompositionEvent();
    var getTextContentAccessor = require_getTextContentAccessor();
    var keyOf = require_keyOf();
    var END_KEYCODES = [9, 13, 27, 32];
    var START_KEYCODE = 229;
    var useCompositionEvent = ExecutionEnvironment.canUseDOM && "CompositionEvent" in window;
    var useFallbackData = !useCompositionEvent || "documentMode" in document && document.documentMode > 8;
    var topLevelTypes = EventConstants.topLevelTypes;
    var currentComposition = null;
    var eventTypes = {
      compositionEnd: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onCompositionEnd: null }),
          captured: keyOf({ onCompositionEndCapture: null })
        },
        dependencies: [
          topLevelTypes.topBlur,
          topLevelTypes.topCompositionEnd,
          topLevelTypes.topKeyDown,
          topLevelTypes.topKeyPress,
          topLevelTypes.topKeyUp,
          topLevelTypes.topMouseDown
        ]
      },
      compositionStart: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onCompositionStart: null }),
          captured: keyOf({ onCompositionStartCapture: null })
        },
        dependencies: [
          topLevelTypes.topBlur,
          topLevelTypes.topCompositionStart,
          topLevelTypes.topKeyDown,
          topLevelTypes.topKeyPress,
          topLevelTypes.topKeyUp,
          topLevelTypes.topMouseDown
        ]
      },
      compositionUpdate: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onCompositionUpdate: null }),
          captured: keyOf({ onCompositionUpdateCapture: null })
        },
        dependencies: [
          topLevelTypes.topBlur,
          topLevelTypes.topCompositionUpdate,
          topLevelTypes.topKeyDown,
          topLevelTypes.topKeyPress,
          topLevelTypes.topKeyUp,
          topLevelTypes.topMouseDown
        ]
      }
    };
    function getCompositionEventType(topLevelType) {
      switch (topLevelType) {
        case topLevelTypes.topCompositionStart:
          return eventTypes.compositionStart;
        case topLevelTypes.topCompositionEnd:
          return eventTypes.compositionEnd;
        case topLevelTypes.topCompositionUpdate:
          return eventTypes.compositionUpdate;
      }
    }
    function isFallbackStart(topLevelType, nativeEvent) {
      return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
    }
    function isFallbackEnd(topLevelType, nativeEvent) {
      switch (topLevelType) {
        case topLevelTypes.topKeyUp:
          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
        case topLevelTypes.topKeyDown:
          return nativeEvent.keyCode !== START_KEYCODE;
        case topLevelTypes.topKeyPress:
        case topLevelTypes.topMouseDown:
        case topLevelTypes.topBlur:
          return true;
        default:
          return false;
      }
    }
    function FallbackCompositionState(root) {
      this.root = root;
      this.startSelection = ReactInputSelection.getSelection(root);
      this.startValue = this.getText();
    }
    FallbackCompositionState.prototype.getText = function() {
      return this.root.value || this.root[getTextContentAccessor()];
    };
    FallbackCompositionState.prototype.getData = function() {
      var endValue = this.getText();
      var prefixLength = this.startSelection.start;
      var suffixLength = this.startValue.length - this.startSelection.end;
      return endValue.substr(
        prefixLength,
        endValue.length - suffixLength - prefixLength
      );
    };
    var CompositionEventPlugin = {
      eventTypes,
      /**
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var eventType;
        var data;
        if (useCompositionEvent) {
          eventType = getCompositionEventType(topLevelType);
        } else if (!currentComposition) {
          if (isFallbackStart(topLevelType, nativeEvent)) {
            eventType = eventTypes.compositionStart;
          }
        } else if (isFallbackEnd(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionEnd;
        }
        if (useFallbackData) {
          if (!currentComposition && eventType === eventTypes.compositionStart) {
            currentComposition = new FallbackCompositionState(topLevelTarget);
          } else if (eventType === eventTypes.compositionEnd) {
            if (currentComposition) {
              data = currentComposition.getData();
              currentComposition = null;
            }
          }
        }
        if (eventType) {
          var event = SyntheticCompositionEvent.getPooled(
            eventType,
            topLevelTargetID,
            nativeEvent
          );
          if (data) {
            event.data = data;
          }
          EventPropagators.accumulateTwoPhaseDispatches(event);
          return event;
        }
      }
    };
    module.exports = CompositionEventPlugin;
  }
});

// node_modules/react-component/lib/DefaultEventPluginOrder.js
var require_DefaultEventPluginOrder = __commonJS({
  "node_modules/react-component/lib/DefaultEventPluginOrder.js"(exports, module) {
    "use strict";
    var keyOf = require_keyOf();
    var DefaultEventPluginOrder = [
      keyOf({ ResponderEventPlugin: null }),
      keyOf({ SimpleEventPlugin: null }),
      keyOf({ TapEventPlugin: null }),
      keyOf({ EnterLeaveEventPlugin: null }),
      keyOf({ ChangeEventPlugin: null }),
      keyOf({ SelectEventPlugin: null }),
      keyOf({ CompositionEventPlugin: null }),
      keyOf({ AnalyticsEventPlugin: null }),
      keyOf({ MobileSafariClickEventPlugin: null })
    ];
    module.exports = DefaultEventPluginOrder;
  }
});

// node_modules/react-component/lib/SyntheticUIEvent.js
var require_SyntheticUIEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticUIEvent.js"(exports, module) {
    "use strict";
    var SyntheticEvent = require_SyntheticEvent();
    var UIEventInterface = {
      view: null,
      detail: null
    };
    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
    module.exports = SyntheticUIEvent;
  }
});

// node_modules/react-component/lib/SyntheticMouseEvent.js
var require_SyntheticMouseEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticMouseEvent.js"(exports, module) {
    "use strict";
    var SyntheticUIEvent = require_SyntheticUIEvent();
    var ViewportMetrics = require_ViewportMetrics();
    var MouseEventInterface = {
      screenX: null,
      screenY: null,
      clientX: null,
      clientY: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      button: function(event) {
        var button = event.button;
        if ("which" in event) {
          return button;
        }
        return button === 2 ? 2 : button === 4 ? 1 : 0;
      },
      buttons: null,
      relatedTarget: function(event) {
        return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
      },
      // "Proprietary" Interface.
      pageX: function(event) {
        return "pageX" in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
      },
      pageY: function(event) {
        return "pageY" in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
      }
    };
    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
    module.exports = SyntheticMouseEvent;
  }
});

// node_modules/react-component/lib/EnterLeaveEventPlugin.js
var require_EnterLeaveEventPlugin = __commonJS({
  "node_modules/react-component/lib/EnterLeaveEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPropagators = require_EventPropagators();
    var SyntheticMouseEvent = require_SyntheticMouseEvent();
    var ReactMount = require_ReactMount();
    var keyOf = require_keyOf();
    var topLevelTypes = EventConstants.topLevelTypes;
    var getFirstReactDOM = ReactMount.getFirstReactDOM;
    var eventTypes = {
      mouseEnter: {
        registrationName: keyOf({ onMouseEnter: null }),
        dependencies: [
          topLevelTypes.topMouseOut,
          topLevelTypes.topMouseOver
        ]
      },
      mouseLeave: {
        registrationName: keyOf({ onMouseLeave: null }),
        dependencies: [
          topLevelTypes.topMouseOut,
          topLevelTypes.topMouseOver
        ]
      }
    };
    var extractedEvents = [null, null];
    var EnterLeaveEventPlugin = {
      eventTypes,
      /**
       * For almost every interaction we care about, there will be both a top-level
       * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
       * we do not extract duplicate events. However, moving the mouse into the
       * browser from outside will not fire a `mouseout` event. In this case, we use
       * the `mouseover` top-level event.
       *
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
          return null;
        }
        if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
          return null;
        }
        var win;
        if (topLevelTarget.window === topLevelTarget) {
          win = topLevelTarget;
        } else {
          var doc = topLevelTarget.ownerDocument;
          if (doc) {
            win = doc.defaultView || doc.parentWindow;
          } else {
            win = window;
          }
        }
        var from, to;
        if (topLevelType === topLevelTypes.topMouseOut) {
          from = topLevelTarget;
          to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
        } else {
          from = win;
          to = topLevelTarget;
        }
        if (from === to) {
          return null;
        }
        var fromID = from ? ReactMount.getID(from) : "";
        var toID = to ? ReactMount.getID(to) : "";
        var leave = SyntheticMouseEvent.getPooled(
          eventTypes.mouseLeave,
          fromID,
          nativeEvent
        );
        leave.type = "mouseleave";
        leave.target = from;
        leave.relatedTarget = to;
        var enter = SyntheticMouseEvent.getPooled(
          eventTypes.mouseEnter,
          toID,
          nativeEvent
        );
        enter.type = "mouseenter";
        enter.target = to;
        enter.relatedTarget = from;
        EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
        extractedEvents[0] = leave;
        extractedEvents[1] = enter;
        return extractedEvents;
      }
    };
    module.exports = EnterLeaveEventPlugin;
  }
});

// node_modules/react-component/lib/MobileSafariClickEventPlugin.js
var require_MobileSafariClickEventPlugin = __commonJS({
  "node_modules/react-component/lib/MobileSafariClickEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var emptyFunction = require_emptyFunction();
    var topLevelTypes = EventConstants.topLevelTypes;
    var MobileSafariClickEventPlugin = {
      eventTypes: null,
      /**
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        if (topLevelType === topLevelTypes.topTouchStart) {
          var target = nativeEvent.target;
          if (target && !target.onclick) {
            target.onclick = emptyFunction;
          }
        }
      }
    };
    module.exports = MobileSafariClickEventPlugin;
  }
});

// node_modules/react-component/lib/toArray.js
var require_toArray = __commonJS({
  "node_modules/react-component/lib/toArray.js"(exports, module) {
    var invariant = require_invariant();
    function toArray(obj) {
      var length = obj.length;
      require_React().__DEV__ === true ? invariant(
        !Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"),
        "toArray: Array-like object expected"
      ) : invariant(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"));
      require_React().__DEV__ === true ? invariant(
        typeof length === "number",
        "toArray: Object needs a length property"
      ) : invariant(typeof length === "number");
      require_React().__DEV__ === true ? invariant(
        length === 0 || length - 1 in obj,
        "toArray: Object should have keys for indices"
      ) : invariant(length === 0 || length - 1 in obj);
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {
        }
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  }
});

// node_modules/react-component/lib/createArrayFrom.js
var require_createArrayFrom = __commonJS({
  "node_modules/react-component/lib/createArrayFrom.js"(exports, module) {
    var toArray = require_toArray();
    function hasArrayNature(obj) {
      return (
        // not null/false
        !!obj && // arrays are objects, NodeLists are functions in Safari
        (typeof obj == "object" || typeof obj == "function") && // quacks like an array
        "length" in obj && // not window
        !("setInterval" in obj) && // no DOM node should be considered an array-like
        // a 'select' element has 'length' and 'item' properties on IE8
        typeof obj.nodeType != "number" && // a real array
        // HTMLCollection/NodeList
        (Array.isArray(obj) || // arguments
        "callee" in obj || "item" in obj)
      );
    }
    function createArrayFrom(obj) {
      if (!hasArrayNature(obj)) {
        return [obj];
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else {
        return toArray(obj);
      }
    }
    module.exports = createArrayFrom;
  }
});

// node_modules/react-component/lib/getMarkupWrap.js
var require_getMarkupWrap = __commonJS({
  "node_modules/react-component/lib/getMarkupWrap.js"(exports, module) {
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var invariant = require_invariant();
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
    var shouldWrap = {
      // Force wrapping for SVG elements because if they get created inside a <div>,
      // they will be initialized in the wrong namespace (and will not display).
      "circle": true,
      "defs": true,
      "g": true,
      "line": true,
      "linearGradient": true,
      "path": true,
      "polygon": true,
      "polyline": true,
      "radialGradient": true,
      "rect": true,
      "stop": true,
      "text": true
    };
    var selectWrap = [1, '<select multiple="true">', "</select>"];
    var tableWrap = [1, "<table>", "</table>"];
    var trWrap = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
    var svgWrap = [1, "<svg>", "</svg>"];
    var markupWrap = {
      "*": [1, "?<div>", "</div>"],
      "area": [1, "<map>", "</map>"],
      "col": [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      "legend": [1, "<fieldset>", "</fieldset>"],
      "param": [1, "<object>", "</object>"],
      "tr": [2, "<table><tbody>", "</tbody></table>"],
      "optgroup": selectWrap,
      "option": selectWrap,
      "caption": tableWrap,
      "colgroup": tableWrap,
      "tbody": tableWrap,
      "tfoot": tableWrap,
      "thead": tableWrap,
      "td": trWrap,
      "th": trWrap,
      "circle": svgWrap,
      "defs": svgWrap,
      "g": svgWrap,
      "line": svgWrap,
      "linearGradient": svgWrap,
      "path": svgWrap,
      "polygon": svgWrap,
      "polyline": svgWrap,
      "radialGradient": svgWrap,
      "rect": svgWrap,
      "stop": svgWrap,
      "text": svgWrap
    };
    function getMarkupWrap(nodeName) {
      require_React().__DEV__ === true ? invariant(!!dummyNode, "Markup wrapping node not initialized") : invariant(!!dummyNode);
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = "*";
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === "*") {
          dummyNode.innerHTML = "<link />";
        } else {
          dummyNode.innerHTML = "<" + nodeName + "></" + nodeName + ">";
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  }
});

// node_modules/react-component/lib/createNodesFromMarkup.js
var require_createNodesFromMarkup = __commonJS({
  "node_modules/react-component/lib/createNodesFromMarkup.js"(exports, module) {
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var createArrayFrom = require_createArrayFrom();
    var getMarkupWrap = require_getMarkupWrap();
    var invariant = require_invariant();
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      require_React().__DEV__ === true ? invariant(!!dummyNode, "createNodesFromMarkup dummy not initialized") : invariant(!!dummyNode);
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName("script");
      if (scripts.length) {
        require_React().__DEV__ === true ? invariant(
          handleScript,
          "createNodesFromMarkup(...): Unexpected <script> element rendered."
        ) : invariant(handleScript);
        createArrayFrom(scripts).forEach(handleScript);
      }
      var nodes = createArrayFrom(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  }
});

// node_modules/react-component/lib/Danger.js
var require_Danger = __commonJS({
  "node_modules/react-component/lib/Danger.js"(exports, module) {
    "use strict";
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var createNodesFromMarkup = require_createNodesFromMarkup();
    var emptyFunction = require_emptyFunction();
    var getMarkupWrap = require_getMarkupWrap();
    var invariant = require_invariant();
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = "data-danger-index";
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(" "));
    }
    var Danger = {
      /**
       * Renders markup into an array of nodes. The markup is expected to render
       * into a list of root nodes. Also, the length of `resultList` and
       * `markupList` should be the same.
       *
       * @param {array<string>} markupList List of markup strings to render.
       * @return {array<DOMElement>} List of rendered nodes.
       * @internal
       */
      dangerouslyRenderMarkup: function(markupList) {
        require_React().__DEV__ === true ? invariant(
          ExecutionEnvironment.canUseDOM,
          "dangerouslyRenderMarkup(...): Cannot render markup in a Worker thread. This is likely a bug in the framework. Please report immediately."
        ) : invariant(ExecutionEnvironment.canUseDOM);
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          require_React().__DEV__ === true ? invariant(
            markupList[i],
            "dangerouslyRenderMarkup(...): Missing markup."
          ) : invariant(markupList[i]);
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : "*";
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          for (var resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(
                OPEN_TAG_NAME_EXP,
                // This index will be parsed back out below.
                "$1 " + RESULT_INDEX_ATTR + '="' + resultIndex + '" '
              );
            }
          }
          var renderNodes = createNodesFromMarkup(
            markupListByNodeName.join(""),
            emptyFunction
            // Do nothing special with <script> tags.
          );
          for (i = 0; i < renderNodes.length; ++i) {
            var renderNode = renderNodes[i];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              require_React().__DEV__ === true ? invariant(
                !resultList.hasOwnProperty(resultIndex),
                "Danger: Assigning to an already-occupied result index."
              ) : invariant(!resultList.hasOwnProperty(resultIndex));
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if (require_React().__DEV__ === true) {
              console.error(
                "Danger: Discarding unexpected node:",
                renderNode
              );
            }
          }
        }
        require_React().__DEV__ === true ? invariant(
          resultListAssignmentCount === resultList.length,
          "Danger: Did not assign to every index of resultList."
        ) : invariant(resultListAssignmentCount === resultList.length);
        require_React().__DEV__ === true ? invariant(
          resultList.length === markupList.length,
          "Danger: Expected markup to render %s nodes, but rendered %s.",
          markupList.length,
          resultList.length
        ) : invariant(resultList.length === markupList.length);
        return resultList;
      },
      /**
       * Replaces a node with a string of markup at its current position within its
       * parent. The markup must render into a single root node.
       *
       * @param {DOMElement} oldChild Child node to replace.
       * @param {string} markup Markup to render in place of the child node.
       * @internal
       */
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        require_React().__DEV__ === true ? invariant(
          ExecutionEnvironment.canUseDOM,
          "dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. This is likely a bug in the framework. Please report immediately."
        ) : invariant(ExecutionEnvironment.canUseDOM);
        require_React().__DEV__ === true ? invariant(markup, "dangerouslyReplaceNodeWithMarkup(...): Missing markup.") : invariant(markup);
        require_React().__DEV__ === true ? invariant(
          oldChild.tagName.toLowerCase() !== "html",
          "dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See renderComponentToString()."
        ) : invariant(oldChild.tagName.toLowerCase() !== "html");
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  }
});

// node_modules/react-component/lib/DOMChildrenOperations.js
var require_DOMChildrenOperations = __commonJS({
  "node_modules/react-component/lib/DOMChildrenOperations.js"(exports, module) {
    "use strict";
    var Danger = require_Danger();
    var ReactMultiChildUpdateTypes = require_ReactMultiChildUpdateTypes();
    var getTextContentAccessor = require_getTextContentAccessor();
    var textContentAccessor = getTextContentAccessor();
    function insertChildAt(parentNode, childNode, index) {
      var childNodes = parentNode.childNodes;
      if (childNodes[index] === childNode) {
        return;
      }
      if (childNode.parentNode === parentNode) {
        parentNode.removeChild(childNode);
      }
      if (index >= childNodes.length) {
        parentNode.appendChild(childNode);
      } else {
        parentNode.insertBefore(childNode, childNodes[index]);
      }
    }
    var updateTextContent;
    if (textContentAccessor === "textContent") {
      updateTextContent = function(node, text) {
        node.textContent = text;
      };
    } else {
      updateTextContent = function(node, text) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        if (text) {
          var doc = node.ownerDocument || document;
          node.appendChild(doc.createTextNode(text));
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent,
      /**
       * Updates a component's children by processing a series of updates. The
       * update configurations are each expected to have a `parentNode` property.
       *
       * @param {array<object>} updates List of update configurations.
       * @param {array<string>} markupList List of markup strings.
       * @internal
       */
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; update = updates[i]; i++) {
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; update = updates[k]; k++) {
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(
                update.parentNode,
                renderedMarkup[update.markupIndex],
                update.toIndex
              );
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(
                update.parentNode,
                initialChildren[update.parentID][update.fromIndex],
                update.toIndex
              );
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              updateTextContent(
                update.parentNode,
                update.textContent
              );
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  }
});

// node_modules/react-component/lib/ReactDOMIDOperations.js
var require_ReactDOMIDOperations = __commonJS({
  "node_modules/react-component/lib/ReactDOMIDOperations.js"(exports, module) {
    "use strict";
    var CSSPropertyOperations = require_CSSPropertyOperations();
    var DOMChildrenOperations = require_DOMChildrenOperations();
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var ReactMount = require_ReactMount();
    var ReactPerf = require_ReactPerf();
    var invariant = require_invariant();
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: "`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.",
      style: "`style` must be set using `updateStylesByID()`."
    };
    var useWhitespaceWorkaround;
    var ReactDOMIDOperations = {
      /**
       * Updates a DOM node with new property values. This should only be used to
       * update DOM properties in `DOMProperty`.
       *
       * @param {string} id ID of the node to update.
       * @param {string} name A valid property name, see `DOMProperty`.
       * @param {*} value New value of the property.
       * @internal
       */
      updatePropertyByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "updatePropertyByID",
        function(id, name, value) {
          var node = ReactMount.getNode(id);
          require_React().__DEV__ === true ? invariant(
            !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
            "updatePropertyByID(...): %s",
            INVALID_PROPERTY_ERRORS[name]
          ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
          if (value != null) {
            DOMPropertyOperations.setValueForProperty(node, name, value);
          } else {
            DOMPropertyOperations.deleteValueForProperty(node, name);
          }
        }
      ),
      /**
       * Updates a DOM node to remove a property. This should only be used to remove
       * DOM properties in `DOMProperty`.
       *
       * @param {string} id ID of the node to update.
       * @param {string} name A property name to remove, see `DOMProperty`.
       * @internal
       */
      deletePropertyByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "deletePropertyByID",
        function(id, name, value) {
          var node = ReactMount.getNode(id);
          require_React().__DEV__ === true ? invariant(
            !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
            "updatePropertyByID(...): %s",
            INVALID_PROPERTY_ERRORS[name]
          ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
          DOMPropertyOperations.deleteValueForProperty(node, name, value);
        }
      ),
      /**
       * Updates a DOM node with new style values. If a value is specified as '',
       * the corresponding style property will be unset.
       *
       * @param {string} id ID of the node to update.
       * @param {object} styles Mapping from styles to values.
       * @internal
       */
      updateStylesByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "updateStylesByID",
        function(id, styles) {
          var node = ReactMount.getNode(id);
          CSSPropertyOperations.setValueForStyles(node, styles);
        }
      ),
      /**
       * Updates a DOM node's innerHTML.
       *
       * @param {string} id ID of the node to update.
       * @param {string} html An HTML string.
       * @internal
       */
      updateInnerHTMLByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "updateInnerHTMLByID",
        function(id, html) {
          var node = ReactMount.getNode(id);
          if (useWhitespaceWorkaround === void 0) {
            var temp = document.createElement("div");
            temp.innerHTML = " ";
            useWhitespaceWorkaround = temp.innerHTML === "";
          }
          if (useWhitespaceWorkaround) {
            node.parentNode.replaceChild(node, node);
          }
          if (useWhitespaceWorkaround && html.match(/^[ \r\n\t\f]/)) {
            node.innerHTML = "\uFEFF" + html;
            node.firstChild.deleteData(0, 1);
          } else {
            node.innerHTML = html;
          }
        }
      ),
      /**
       * Updates a DOM node's text content set by `props.content`.
       *
       * @param {string} id ID of the node to update.
       * @param {string} content Text content.
       * @internal
       */
      updateTextContentByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "updateTextContentByID",
        function(id, content) {
          var node = ReactMount.getNode(id);
          DOMChildrenOperations.updateTextContent(node, content);
        }
      ),
      /**
       * Replaces a DOM node that exists in the document with markup.
       *
       * @param {string} id ID of child to be replaced.
       * @param {string} markup Dangerous markup to inject in place of child.
       * @internal
       * @see {Danger.dangerouslyReplaceNodeWithMarkup}
       */
      dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure(
        "ReactDOMIDOperations",
        "dangerouslyReplaceNodeWithMarkupByID",
        function(id, markup) {
          var node = ReactMount.getNode(id);
          DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
        }
      ),
      /**
       * Updates a component's children by processing a series of updates.
       *
       * @param {array<object>} updates List of update configurations.
       * @param {array<string>} markup List of markup strings.
       * @internal
       */
      dangerouslyProcessChildrenUpdates: ReactPerf.measure(
        "ReactDOMIDOperations",
        "dangerouslyProcessChildrenUpdates",
        function(updates, markup) {
          for (var i = 0; i < updates.length; i++) {
            updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
          }
          DOMChildrenOperations.processUpdates(updates, markup);
        }
      )
    };
    module.exports = ReactDOMIDOperations;
  }
});

// node_modules/react-component/lib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/react-component/lib/adler32.js"(exports, module) {
    "use strict";
    var MOD = 65521;
    function adler32(data) {
      var a = 1;
      var b = 0;
      for (var i = 0; i < data.length; i++) {
        a = (a + data.charCodeAt(i)) % MOD;
        b = (b + a) % MOD;
      }
      return a | b << 16;
    }
    module.exports = adler32;
  }
});

// node_modules/react-component/lib/ReactMarkupChecksum.js
var require_ReactMarkupChecksum = __commonJS({
  "node_modules/react-component/lib/ReactMarkupChecksum.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var ReactMarkupChecksum = {
      CHECKSUM_ATTR_NAME: "data-react-checksum",
      /**
       * @param {string} markup Markup string
       * @return {string} Markup string with checksum attribute attached
       */
      addChecksumToMarkup: function(markup) {
        var checksum = adler32(markup);
        return markup.replace(
          ">",
          " " + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">'
        );
      },
      /**
       * @param {string} markup to use
       * @param {DOMElement} element root React element
       * @returns {boolean} whether or not the markup is the same
       */
      canReuseMarkup: function(markup, element) {
        var existingChecksum = element.getAttribute(
          ReactMarkupChecksum.CHECKSUM_ATTR_NAME
        );
        existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
        var markupChecksum = adler32(markup);
        return markupChecksum === existingChecksum;
      }
    };
    module.exports = ReactMarkupChecksum;
  }
});

// node_modules/react-component/lib/ReactMountReady.js
var require_ReactMountReady = __commonJS({
  "node_modules/react-component/lib/ReactMountReady.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var mixInto = require_mixInto();
    function ReactMountReady(initialCollection) {
      this._queue = initialCollection || null;
    }
    mixInto(ReactMountReady, {
      /**
       * Enqueues a callback to be invoked when `notifyAll` is invoked. This is used
       * to enqueue calls to `componentDidMount` and `componentDidUpdate`.
       *
       * @param {ReactComponent} component Component being rendered.
       * @param {function(DOMElement)} callback Invoked when `notifyAll` is invoked.
       * @internal
       */
      enqueue: function(component, callback) {
        this._queue = this._queue || [];
        this._queue.push({ component, callback });
      },
      /**
       * Invokes all enqueued callbacks and clears the queue. This is invoked after
       * the DOM representation of a component has been created or updated.
       *
       * @internal
       */
      notifyAll: function() {
        var queue = this._queue;
        if (queue) {
          this._queue = null;
          for (var i = 0, l = queue.length; i < l; i++) {
            var component = queue[i].component;
            var callback = queue[i].callback;
            callback.call(component);
          }
          queue.length = 0;
        }
      },
      /**
       * Resets the internal queue.
       *
       * @internal
       */
      reset: function() {
        this._queue = null;
      },
      /**
       * `PooledClass` looks for this.
       */
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(ReactMountReady);
    module.exports = ReactMountReady;
  }
});

// node_modules/react-component/lib/ReactPutListenerQueue.js
var require_ReactPutListenerQueue = __commonJS({
  "node_modules/react-component/lib/ReactPutListenerQueue.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var ReactEventEmitter = require_ReactEventEmitter();
    var mixInto = require_mixInto();
    function ReactPutListenerQueue() {
      this.listenersToPut = [];
    }
    mixInto(ReactPutListenerQueue, {
      enqueuePutListener: function(rootNodeID, propKey, propValue) {
        this.listenersToPut.push({
          rootNodeID,
          propKey,
          propValue
        });
      },
      putListeners: function() {
        for (var i = 0; i < this.listenersToPut.length; i++) {
          var listenerToPut = this.listenersToPut[i];
          ReactEventEmitter.putListener(
            listenerToPut.rootNodeID,
            listenerToPut.propKey,
            listenerToPut.propValue
          );
        }
      },
      reset: function() {
        this.listenersToPut.length = 0;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(ReactPutListenerQueue);
    module.exports = ReactPutListenerQueue;
  }
});

// node_modules/react-component/lib/Transaction.js
var require_Transaction = __commonJS({
  "node_modules/react-component/lib/Transaction.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var Mixin = {
      /**
       * Sets up this instance so that it is prepared for collecting metrics. Does
       * so such that this setup method may be used on an instance that is already
       * initialized, in a way that does not consume additional memory upon reuse.
       * That can be useful if you decide to make your subclass of this mixin a
       * "PooledClass".
       */
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
          this.wrapperInitData = [];
        } else {
          this.wrapperInitData.length = 0;
        }
        if (!this.timingMetrics) {
          this.timingMetrics = {};
        }
        this.timingMetrics.methodInvocationTime = 0;
        if (!this.timingMetrics.wrapperInitTimes) {
          this.timingMetrics.wrapperInitTimes = [];
        } else {
          this.timingMetrics.wrapperInitTimes.length = 0;
        }
        if (!this.timingMetrics.wrapperCloseTimes) {
          this.timingMetrics.wrapperCloseTimes = [];
        } else {
          this.timingMetrics.wrapperCloseTimes.length = 0;
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      /**
       * @abstract
       * @return {Array<TransactionWrapper>} Array of transaction wrappers.
       */
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      /**
       * Executes the function within a safety window. Use this for the top level
       * methods that result in large amounts of computation/mutations that would
       * need to be safety checked.
       *
       * @param {function} method Member of scope to call.
       * @param {Object} scope Scope to invoke from.
       * @param {Object?=} args... Arguments to pass to the method (optional).
       *                           Helps prevent need to bind in many cases.
       * @return Return value from `method`.
       */
      perform: function(method, scope, a, b, c, d, e, f) {
        require_React().__DEV__ === true ? invariant(
          !this.isInTransaction(),
          "Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction."
        ) : invariant(!this.isInTransaction());
        var memberStart = Date.now();
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          var memberEnd = Date.now();
          this.methodInvocationTime += memberEnd - memberStart;
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {
              }
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        var wrapperInitTimes = this.timingMetrics.wrapperInitTimes;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var initStart = Date.now();
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            var curInitTime = wrapperInitTimes[i];
            var initEnd = Date.now();
            wrapperInitTimes[i] = (curInitTime || 0) + (initEnd - initStart);
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {
              }
            }
          }
        }
      },
      /**
       * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
       * them the respective return values of `this.transactionWrappers.init[i]`
       * (`close`rs that correspond to initializers that failed will not be
       * invoked).
       */
      closeAll: function(startIndex) {
        require_React().__DEV__ === true ? invariant(
          this.isInTransaction(),
          "Transaction.closeAll(): Cannot close transaction when none are open."
        ) : invariant(this.isInTransaction());
        var transactionWrappers = this.transactionWrappers;
        var wrapperCloseTimes = this.timingMetrics.wrapperCloseTimes;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var closeStart = Date.now();
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR) {
              wrapper.close && wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            var closeEnd = Date.now();
            var curCloseTime = wrapperCloseTimes[i];
            wrapperCloseTimes[i] = (curCloseTime || 0) + (closeEnd - closeStart);
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {
              }
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin,
      /**
       * Token to look for to determine if an error occured.
       */
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  }
});

// node_modules/react-component/lib/ReactReconcileTransaction.js
var require_ReactReconcileTransaction = __commonJS({
  "node_modules/react-component/lib/ReactReconcileTransaction.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var ReactEventEmitter = require_ReactEventEmitter();
    var ReactInputSelection = require_ReactInputSelection();
    var ReactMountReady = require_ReactMountReady();
    var ReactPutListenerQueue = require_ReactPutListenerQueue();
    var Transaction = require_Transaction();
    var mixInto = require_mixInto();
    var SELECTION_RESTORATION = {
      /**
       * @return {Selection} Selection information.
       */
      initialize: ReactInputSelection.getSelectionInformation,
      /**
       * @param {Selection} sel Selection information returned from `initialize`.
       */
      close: ReactInputSelection.restoreSelection
    };
    var EVENT_SUPPRESSION = {
      /**
       * @return {boolean} The enabled status of `ReactEventEmitter` before the
       * reconciliation.
       */
      initialize: function() {
        var currentlyEnabled = ReactEventEmitter.isEnabled();
        ReactEventEmitter.setEnabled(false);
        return currentlyEnabled;
      },
      /**
       * @param {boolean} previouslyEnabled Enabled status of `ReactEventEmitter`
       *   before the reconciliation occured. `close` restores the previous value.
       */
      close: function(previouslyEnabled) {
        ReactEventEmitter.setEnabled(previouslyEnabled);
      }
    };
    var ON_DOM_READY_QUEUEING = {
      /**
       * Initializes the internal `onDOMReady` queue.
       */
      initialize: function() {
        this.reactMountReady.reset();
      },
      /**
       * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
       */
      close: function() {
        this.reactMountReady.notifyAll();
      }
    };
    var PUT_LISTENER_QUEUEING = {
      initialize: function() {
        this.putListenerQueue.reset();
      },
      close: function() {
        this.putListenerQueue.putListeners();
      }
    };
    var TRANSACTION_WRAPPERS = [
      PUT_LISTENER_QUEUEING,
      SELECTION_RESTORATION,
      EVENT_SUPPRESSION,
      ON_DOM_READY_QUEUEING
    ];
    function ReactReconcileTransaction() {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = false;
      this.reactMountReady = ReactMountReady.getPooled(null);
      this.putListenerQueue = ReactPutListenerQueue.getPooled();
    }
    var Mixin = {
      /**
       * @see Transaction
       * @abstract
       * @final
       * @return {array<object>} List of operation wrap proceedures.
       *   TODO: convert to array<TransactionWrapper>
       */
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      /**
       * @return {object} The queue to collect `onDOMReady` callbacks with.
       *   TODO: convert to ReactMountReady
       */
      getReactMountReady: function() {
        return this.reactMountReady;
      },
      getPutListenerQueue: function() {
        return this.putListenerQueue;
      },
      /**
       * `PooledClass` looks for this, and will invoke this before allowing this
       * instance to be resused.
       */
      destructor: function() {
        ReactMountReady.release(this.reactMountReady);
        this.reactMountReady = null;
        ReactPutListenerQueue.release(this.putListenerQueue);
        this.putListenerQueue = null;
      }
    };
    mixInto(ReactReconcileTransaction, Transaction.Mixin);
    mixInto(ReactReconcileTransaction, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction;
  }
});

// node_modules/react-component/lib/ReactComponentBrowserEnvironment.js
var require_ReactComponentBrowserEnvironment = __commonJS({
  "node_modules/react-component/lib/ReactComponentBrowserEnvironment.js"(exports, module) {
    "use strict";
    var ReactDOMIDOperations = require_ReactDOMIDOperations();
    var ReactMarkupChecksum = require_ReactMarkupChecksum();
    var ReactMount = require_ReactMount();
    var ReactPerf = require_ReactPerf();
    var ReactReconcileTransaction = require_ReactReconcileTransaction();
    var getReactRootElementInContainer = require_getReactRootElementInContainer();
    var invariant = require_invariant();
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var ReactComponentBrowserEnvironment = {
      ReactReconcileTransaction,
      BackendIDOperations: ReactDOMIDOperations,
      /**
       * If a particular environment requires that some resources be cleaned up,
       * specify this in the injected Mixin. In the DOM, we would likely want to
       * purge any cached node ID lookups.
       *
       * @private
       */
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      },
      /**
       * @param {string} markup Markup string to place into the DOM Element.
       * @param {DOMElement} container DOM Element to insert markup into.
       * @param {boolean} shouldReuseMarkup Should reuse the existing markup in the
       * container if possible.
       */
      mountImageIntoNode: ReactPerf.measure(
        "ReactComponentBrowserEnvironment",
        "mountImageIntoNode",
        function(markup, container, shouldReuseMarkup) {
          require_React().__DEV__ === true ? invariant(
            container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE),
            "mountComponentIntoNode(...): Target container is not valid."
          ) : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
          if (shouldReuseMarkup) {
            if (ReactMarkupChecksum.canReuseMarkup(
              markup,
              getReactRootElementInContainer(container)
            )) {
              return;
            } else {
              require_React().__DEV__ === true ? invariant(
                container.nodeType !== DOC_NODE_TYPE,
                "You're trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side."
              ) : invariant(container.nodeType !== DOC_NODE_TYPE);
              if (require_React().__DEV__ === true) {
                console.warn(
                  "React attempted to use reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injectednew markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server."
                );
              }
            }
          }
          require_React().__DEV__ === true ? invariant(
            container.nodeType !== DOC_NODE_TYPE,
            "You're trying to render a component to the document but you didn't use server rendering. We can't do this without using server rendering due to cross-browser quirks. See renderComponentToString() for server rendering."
          ) : invariant(container.nodeType !== DOC_NODE_TYPE);
          container.innerHTML = markup;
        }
      )
    };
    module.exports = ReactComponentBrowserEnvironment;
  }
});

// node_modules/react-component/lib/ReactEventTopLevelCallback.js
var require_ReactEventTopLevelCallback = __commonJS({
  "node_modules/react-component/lib/ReactEventTopLevelCallback.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var ReactEventEmitter = require_ReactEventEmitter();
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactMount = require_ReactMount();
    var getEventTarget = require_getEventTarget();
    var mixInto = require_mixInto();
    var _topLevelListenersEnabled = true;
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function handleTopLevelImpl(topLevelType, nativeEvent, bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(
        getEventTarget(nativeEvent)
      ) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || "";
        ReactEventEmitter.handleTopLevel(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
      }
    }
    function TopLevelCallbackBookKeeping() {
      this.ancestors = [];
    }
    mixInto(TopLevelCallbackBookKeeping, {
      destructor: function() {
        this.ancestors.length = 0;
      }
    });
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping);
    var ReactEventTopLevelCallback = {
      /**
       * Sets whether or not any created callbacks should be enabled.
       *
       * @param {boolean} enabled True if callbacks should be enabled.
       */
      setEnabled: function(enabled) {
        _topLevelListenersEnabled = !!enabled;
      },
      /**
       * @return {boolean} True if callbacks are enabled.
       */
      isEnabled: function() {
        return _topLevelListenersEnabled;
      },
      /**
       * Creates a callback for the supplied `topLevelType` that could be added as
       * a listener to the document. The callback computes a `topLevelTarget` which
       * should be the root node of a mounted React component where the listener
       * is attached.
       *
       * @param {string} topLevelType Record from `EventConstants`.
       * @return {function} Callback for handling top-level events.
       */
      createTopLevelCallback: function(topLevelType) {
        return function(nativeEvent) {
          if (!_topLevelListenersEnabled) {
            return;
          }
          var bookKeeping = TopLevelCallbackBookKeeping.getPooled();
          try {
            handleTopLevelImpl(topLevelType, nativeEvent, bookKeeping);
          } finally {
            TopLevelCallbackBookKeeping.release(bookKeeping);
          }
        };
      }
    };
    module.exports = ReactEventTopLevelCallback;
  }
});

// node_modules/react-component/lib/AutoFocusMixin.js
var require_AutoFocusMixin = __commonJS({
  "node_modules/react-component/lib/AutoFocusMixin.js"(exports, module) {
    "use strict";
    var focusNode = require_focusNode();
    var AutoFocusMixin = {
      componentDidMount: function() {
        if (this.props.autoFocus) {
          focusNode(this.getDOMNode());
        }
      }
    };
    module.exports = AutoFocusMixin;
  }
});

// node_modules/react-component/lib/ReactDOMButton.js
var require_ReactDOMButton = __commonJS({
  "node_modules/react-component/lib/ReactDOMButton.js"(exports, module) {
    "use strict";
    var AutoFocusMixin = require_AutoFocusMixin();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var keyMirror = require_keyMirror();
    var button = ReactDOM.button;
    var mouseListenerNames = keyMirror({
      onClick: true,
      onDoubleClick: true,
      onMouseDown: true,
      onMouseMove: true,
      onMouseUp: true,
      onClickCapture: true,
      onDoubleClickCapture: true,
      onMouseDownCapture: true,
      onMouseMoveCapture: true,
      onMouseUpCapture: true
    });
    var ReactDOMButton = ReactCompositeComponent.createClass({
      displayName: "ReactDOMButton",
      mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
      render: function() {
        var props = {};
        for (var key in this.props) {
          if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
            props[key] = this.props[key];
          }
        }
        return button(props, this.props.children);
      }
    });
    module.exports = ReactDOMButton;
  }
});

// node_modules/react-component/lib/ReactDOMForm.js
var require_ReactDOMForm = __commonJS({
  "node_modules/react-component/lib/ReactDOMForm.js"(exports, module) {
    "use strict";
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var ReactEventEmitter = require_ReactEventEmitter();
    var EventConstants = require_EventConstants();
    var form = ReactDOM.form;
    var ReactDOMForm = ReactCompositeComponent.createClass({
      displayName: "ReactDOMForm",
      mixins: [ReactBrowserComponentMixin],
      render: function() {
        return this.transferPropsTo(form(null, this.props.children));
      },
      componentDidMount: function() {
        ReactEventEmitter.trapBubbledEvent(
          EventConstants.topLevelTypes.topReset,
          "reset",
          this.getDOMNode()
        );
        ReactEventEmitter.trapBubbledEvent(
          EventConstants.topLevelTypes.topSubmit,
          "submit",
          this.getDOMNode()
        );
      }
    });
    module.exports = ReactDOMForm;
  }
});

// node_modules/react-component/lib/ReactDOMImg.js
var require_ReactDOMImg = __commonJS({
  "node_modules/react-component/lib/ReactDOMImg.js"(exports, module) {
    "use strict";
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var ReactEventEmitter = require_ReactEventEmitter();
    var EventConstants = require_EventConstants();
    var img = ReactDOM.img;
    var ReactDOMImg = ReactCompositeComponent.createClass({
      displayName: "ReactDOMImg",
      tagName: "IMG",
      mixins: [ReactBrowserComponentMixin],
      render: function() {
        return img(this.props);
      },
      componentDidMount: function() {
        var node = this.getDOMNode();
        ReactEventEmitter.trapBubbledEvent(
          EventConstants.topLevelTypes.topLoad,
          "load",
          node
        );
        ReactEventEmitter.trapBubbledEvent(
          EventConstants.topLevelTypes.topError,
          "error",
          node
        );
      }
    });
    module.exports = ReactDOMImg;
  }
});

// node_modules/react-component/lib/createObjectFrom.js
var require_createObjectFrom = __commonJS({
  "node_modules/react-component/lib/createObjectFrom.js"(exports, module) {
    function createObjectFrom(keys, values) {
      if (require_React().__DEV__ === true) {
        if (!Array.isArray(keys)) {
          throw new TypeError("Must pass an array of keys.");
        }
      }
      var object = {};
      var isArray = Array.isArray(values);
      if (typeof values == "undefined") {
        values = true;
      }
      for (var ii = keys.length; ii--; ) {
        object[keys[ii]] = isArray ? values[ii] : values;
      }
      return object;
    }
    module.exports = createObjectFrom;
  }
});

// node_modules/react-component/lib/ReactPropTypes.js
var require_ReactPropTypes = __commonJS({
  "node_modules/react-component/lib/ReactPropTypes.js"(exports, module) {
    "use strict";
    var ReactComponent = require_ReactComponent();
    var ReactPropTypeLocationNames = require_ReactPropTypeLocationNames();
    var warning = require_warning();
    var createObjectFrom = require_createObjectFrom();
    var Props = {
      array: createPrimitiveTypeChecker("array"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      shape: createShapeTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      arrayOf: createArrayOfTypeChecker,
      instanceOf: createInstanceTypeChecker,
      renderable: createRenderableTypeChecker(),
      component: createComponentTypeChecker(),
      any: createAnyTypeChecker()
    };
    var ANONYMOUS = "<<anonymous>>";
    function isRenderable(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
          return true;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isRenderable);
          }
          if (ReactComponent.isValidComponent(propValue)) {
            return true;
          }
          for (var k in propValue) {
            if (!isRenderable(propValue[k])) {
              return false;
            }
          }
          return true;
        default:
          return false;
      }
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (propType === "object" && Array.isArray(propValue)) {
        return "array";
      }
      return propType;
    }
    function createAnyTypeChecker() {
      function validateAnyType(shouldWarn, propValue, propName, componentName, location) {
        return true;
      }
      return createChainableTypeChecker(validateAnyType);
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validatePrimitiveType(shouldWarn, propValue, propName, componentName, location) {
        var propType = getPropType(propValue);
        var isValid = propType === expectedType;
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` of type `%s` supplied to `%s`, expected `%s`.",
            ReactPropTypeLocationNames[location],
            propName,
            propType,
            componentName,
            expectedType
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validatePrimitiveType);
    }
    function createEnumTypeChecker(expectedValues) {
      var expectedEnum = createObjectFrom(expectedValues);
      function validateEnumType(shouldWarn, propValue, propName, componentName, location) {
        var isValid = expectedEnum[propValue];
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` supplied to `%s`, expected one of %s.",
            ReactPropTypeLocationNames[location],
            propName,
            componentName,
            JSON.stringify(Object.keys(expectedEnum))
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateEnumType);
    }
    function createShapeTypeChecker(shapeTypes) {
      function validateShapeType(shouldWarn, propValue, propName, componentName, location) {
        var propType = getPropType(propValue);
        var isValid = propType === "object";
        if (isValid) {
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (checker && !checker(propValue, key, componentName, location)) {
              return false;
            }
          }
        }
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` of type `%s` supplied to `%s`, expected `object`.",
            ReactPropTypeLocationNames[location],
            propName,
            propType,
            componentName
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateShapeType);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validateInstanceType(shouldWarn, propValue, propName, componentName, location) {
        var isValid = propValue instanceof expectedClass;
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` supplied to `%s`, expected instance of `%s`.",
            ReactPropTypeLocationNames[location],
            propName,
            componentName,
            expectedClass.name || ANONYMOUS
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateInstanceType);
    }
    function createArrayOfTypeChecker(propTypeChecker) {
      function validateArrayType(shouldWarn, propValue, propName, componentName, location) {
        var isValid = Array.isArray(propValue);
        if (isValid) {
          for (var i = 0; i < propValue.length; i++) {
            if (!propTypeChecker(propValue, i, componentName, location)) {
              return false;
            }
          }
        }
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` supplied to `%s`, expected an array.",
            ReactPropTypeLocationNames[location],
            propName,
            componentName
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateArrayType);
    }
    function createRenderableTypeChecker() {
      function validateRenderableType(shouldWarn, propValue, propName, componentName, location) {
        var isValid = isRenderable(propValue);
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` supplied to `%s`, expected a renderable prop.",
            ReactPropTypeLocationNames[location],
            propName,
            componentName
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateRenderableType);
    }
    function createComponentTypeChecker() {
      function validateComponentType(shouldWarn, propValue, propName, componentName, location) {
        var isValid = ReactComponent.isValidComponent(propValue);
        if (shouldWarn) {
          require_React().__DEV__ === true ? warning(
            isValid,
            "Invalid %s `%s` supplied to `%s`, expected a React component.",
            ReactPropTypeLocationNames[location],
            propName,
            componentName
          ) : null;
        }
        return isValid;
      }
      return createChainableTypeChecker(validateComponentType);
    }
    function createUnionTypeChecker(arrayOfValidators) {
      return function(props, propName, componentName, location) {
        var isValid = false;
        for (var ii = 0; ii < arrayOfValidators.length; ii++) {
          var validate = arrayOfValidators[ii];
          if (typeof validate.weak === "function") {
            validate = validate.weak;
          }
          if (validate(props, propName, componentName, location)) {
            isValid = true;
            break;
          }
        }
        require_React().__DEV__ === true ? warning(
          isValid,
          "Invalid %s `%s` supplied to `%s`.",
          ReactPropTypeLocationNames[location],
          propName,
          componentName || ANONYMOUS
        ) : null;
        return isValid;
      };
    }
    function createChainableTypeChecker(validate) {
      function checkType(isRequired, shouldWarn, props, propName, componentName, location) {
        var propValue = props[propName];
        if (propValue != null) {
          return validate(
            shouldWarn,
            propValue,
            propName,
            componentName || ANONYMOUS,
            location
          );
        } else {
          var isValid = !isRequired;
          if (shouldWarn) {
            require_React().__DEV__ === true ? warning(
              isValid,
              "Required %s `%s` was not specified in `%s`.",
              ReactPropTypeLocationNames[location],
              propName,
              componentName || ANONYMOUS
            ) : null;
          }
          return isValid;
        }
      }
      var checker = checkType.bind(null, false, true);
      checker.weak = checkType.bind(null, false, false);
      checker.isRequired = checkType.bind(null, true, true);
      checker.weak.isRequired = checkType.bind(null, true, false);
      checker.isRequired.weak = checker.weak.isRequired;
      return checker;
    }
    module.exports = Props;
  }
});

// node_modules/react-component/lib/LinkedValueUtils.js
var require_LinkedValueUtils = __commonJS({
  "node_modules/react-component/lib/LinkedValueUtils.js"(exports, module) {
    "use strict";
    var ReactPropTypes = require_ReactPropTypes();
    var invariant = require_invariant();
    var warning = require_warning();
    var hasReadOnlyValue = {
      "button": true,
      "checkbox": true,
      "image": true,
      "hidden": true,
      "radio": true,
      "reset": true,
      "submit": true
    };
    function _assertSingleLink(input) {
      require_React().__DEV__ === true ? invariant(
        input.props.checkedLink == null || input.props.valueLink == null,
        "Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don't want to use valueLink and vice versa."
      ) : invariant(input.props.checkedLink == null || input.props.valueLink == null);
    }
    function _assertValueLink(input) {
      _assertSingleLink(input);
      require_React().__DEV__ === true ? invariant(
        input.props.value == null && input.props.onChange == null,
        "Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don't want to use valueLink."
      ) : invariant(input.props.value == null && input.props.onChange == null);
    }
    function _assertCheckedLink(input) {
      _assertSingleLink(input);
      require_React().__DEV__ === true ? invariant(
        input.props.checked == null && input.props.onChange == null,
        "Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don't want to use checkedLink"
      ) : invariant(input.props.checked == null && input.props.onChange == null);
    }
    function _handleLinkedValueChange(e) {
      this.props.valueLink.requestChange(e.target.value);
    }
    function _handleLinkedCheckChange(e) {
      this.props.checkedLink.requestChange(e.target.checked);
    }
    var LinkedValueUtils = {
      Mixin: {
        propTypes: {
          value: function(props, propName, componentName) {
            if (require_React().__DEV__ === true) {
              require_React().__DEV__ === true ? warning(
                !props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled,
                "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
              ) : null;
            }
          },
          checked: function(props, propName, componentName) {
            if (require_React().__DEV__ === true) {
              require_React().__DEV__ === true ? warning(
                !props[propName] || props.onChange || props.readOnly || props.disabled,
                "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
              ) : null;
            }
          },
          onChange: ReactPropTypes.func
        }
      },
      /**
       * @param {ReactComponent} input Form component
       * @return {*} current value of the input either from value prop or link.
       */
      getValue: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return input.props.valueLink.value;
        }
        return input.props.value;
      },
      /**
       * @param {ReactComponent} input Form component
       * @return {*} current checked status of the input either from checked prop
       *             or link.
       */
      getChecked: function(input) {
        if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return input.props.checkedLink.value;
        }
        return input.props.checked;
      },
      /**
       * @param {ReactComponent} input Form component
       * @return {function} change callback either from onChange prop or link.
       */
      getOnChange: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return _handleLinkedValueChange;
        } else if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return _handleLinkedCheckChange;
        }
        return input.props.onChange;
      }
    };
    module.exports = LinkedValueUtils;
  }
});

// node_modules/react-component/lib/ReactDOMInput.js
var require_ReactDOMInput = __commonJS({
  "node_modules/react-component/lib/ReactDOMInput.js"(exports, module) {
    "use strict";
    var AutoFocusMixin = require_AutoFocusMixin();
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var LinkedValueUtils = require_LinkedValueUtils();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var ReactMount = require_ReactMount();
    var invariant = require_invariant();
    var merge = require_merge();
    var input = ReactDOM.input;
    var instancesByReactID = {};
    var ReactDOMInput = ReactCompositeComponent.createClass({
      displayName: "ReactDOMInput",
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        return {
          checked: this.props.defaultChecked || false,
          value: defaultValue != null ? defaultValue : null
        };
      },
      shouldComponentUpdate: function() {
        return !this._isChanging;
      },
      render: function() {
        var props = merge(this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.value;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.checked;
        props.onChange = this._handleChange;
        return input(props, this.props.children);
      },
      componentDidMount: function() {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this;
      },
      componentWillUnmount: function() {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id];
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
          DOMPropertyOperations.setValueForProperty(
            rootNode,
            "checked",
            this.props.checked || false
          );
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          this._isChanging = true;
          returnValue = onChange.call(this, event);
          this._isChanging = false;
        }
        this.setState({
          checked: event.target.checked,
          value: event.target.value
        });
        var name = this.props.name;
        if (this.props.type === "radio" && name != null) {
          var rootNode = this.getDOMNode();
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          var group = queryRoot.querySelectorAll(
            "input[name=" + JSON.stringify("" + name) + '][type="radio"]'
          );
          for (var i = 0, groupLen = group.length; i < groupLen; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherID = ReactMount.getID(otherNode);
            require_React().__DEV__ === true ? invariant(
              otherID,
              "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
            ) : invariant(otherID);
            var otherInstance = instancesByReactID[otherID];
            require_React().__DEV__ === true ? invariant(
              otherInstance,
              "ReactDOMInput: Unknown radio button ID %s.",
              otherID
            ) : invariant(otherInstance);
            otherInstance.setState({
              checked: false
            });
          }
        }
        return returnValue;
      }
    });
    module.exports = ReactDOMInput;
  }
});

// node_modules/react-component/lib/ReactDOMOption.js
var require_ReactDOMOption = __commonJS({
  "node_modules/react-component/lib/ReactDOMOption.js"(exports, module) {
    "use strict";
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var warning = require_warning();
    var option = ReactDOM.option;
    var ReactDOMOption = ReactCompositeComponent.createClass({
      displayName: "ReactDOMOption",
      mixins: [ReactBrowserComponentMixin],
      componentWillMount: function() {
        if (require_React().__DEV__ === true) {
          require_React().__DEV__ === true ? warning(
            this.props.selected == null,
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ) : null;
        }
      },
      render: function() {
        return option(this.props, this.props.children);
      }
    });
    module.exports = ReactDOMOption;
  }
});

// node_modules/react-component/lib/ReactDOMSelect.js
var require_ReactDOMSelect = __commonJS({
  "node_modules/react-component/lib/ReactDOMSelect.js"(exports, module) {
    "use strict";
    var AutoFocusMixin = require_AutoFocusMixin();
    var LinkedValueUtils = require_LinkedValueUtils();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var invariant = require_invariant();
    var merge = require_merge();
    var select = ReactDOM.select;
    function selectValueType(props, propName, componentName) {
      if (props[propName] == null) {
        return;
      }
      if (props.multiple) {
        require_React().__DEV__ === true ? invariant(
          Array.isArray(props[propName]),
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : invariant(Array.isArray(props[propName]));
      } else {
        require_React().__DEV__ === true ? invariant(
          !Array.isArray(props[propName]),
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ) : invariant(!Array.isArray(props[propName]));
      }
    }
    function updateOptions(component, propValue) {
      var multiple = component.props.multiple;
      var value = propValue != null ? propValue : component.state.value;
      var options = component.getDOMNode().options;
      var selectedValue, i, l;
      if (multiple) {
        selectedValue = {};
        for (i = 0, l = value.length; i < l; ++i) {
          selectedValue["" + value[i]] = true;
        }
      } else {
        selectedValue = "" + value;
      }
      for (i = 0, l = options.length; i < l; i++) {
        var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;
        if (selected !== options[i].selected) {
          options[i].selected = selected;
        }
      }
    }
    var ReactDOMSelect = ReactCompositeComponent.createClass({
      displayName: "ReactDOMSelect",
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      propTypes: {
        defaultValue: selectValueType,
        value: selectValueType
      },
      getInitialState: function() {
        return { value: this.props.defaultValue || (this.props.multiple ? [] : "") };
      },
      componentWillReceiveProps: function(nextProps) {
        if (!this.props.multiple && nextProps.multiple) {
          this.setState({ value: [this.state.value] });
        } else if (this.props.multiple && !nextProps.multiple) {
          this.setState({ value: this.state.value[0] });
        }
      },
      shouldComponentUpdate: function() {
        return !this._isChanging;
      },
      render: function() {
        var props = merge(this.props);
        props.onChange = this._handleChange;
        props.value = null;
        return select(props, this.props.children);
      },
      componentDidMount: function() {
        updateOptions(this, LinkedValueUtils.getValue(this));
      },
      componentDidUpdate: function() {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          updateOptions(this, value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          this._isChanging = true;
          returnValue = onChange.call(this, event);
          this._isChanging = false;
        }
        var selectedValue;
        if (this.props.multiple) {
          selectedValue = [];
          var options = event.target.options;
          for (var i = 0, l = options.length; i < l; i++) {
            if (options[i].selected) {
              selectedValue.push(options[i].value);
            }
          }
        } else {
          selectedValue = event.target.value;
        }
        this.setState({ value: selectedValue });
        return returnValue;
      }
    });
    module.exports = ReactDOMSelect;
  }
});

// node_modules/react-component/lib/ReactDOMTextarea.js
var require_ReactDOMTextarea = __commonJS({
  "node_modules/react-component/lib/ReactDOMTextarea.js"(exports, module) {
    "use strict";
    var AutoFocusMixin = require_AutoFocusMixin();
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var LinkedValueUtils = require_LinkedValueUtils();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactDOM = require_ReactDOM();
    var invariant = require_invariant();
    var merge = require_merge();
    var warning = require_warning();
    var textarea = ReactDOM.textarea;
    var ReactDOMTextarea = ReactCompositeComponent.createClass({
      displayName: "ReactDOMTextarea",
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
          if (require_React().__DEV__ === true) {
            require_React().__DEV__ === true ? warning(
              false,
              "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
            ) : null;
          }
          require_React().__DEV__ === true ? invariant(
            defaultValue == null,
            "If you supply `defaultValue` on a <textarea>, do not pass children."
          ) : invariant(defaultValue == null);
          if (Array.isArray(children)) {
            require_React().__DEV__ === true ? invariant(
              children.length <= 1,
              "<textarea> can only have at most one child."
            ) : invariant(children.length <= 1);
            children = children[0];
          }
          defaultValue = "" + children;
        }
        if (defaultValue == null) {
          defaultValue = "";
        }
        var value = LinkedValueUtils.getValue(this);
        return {
          // We save the initial value so that `ReactDOMComponent` doesn't update
          // `textContent` (unnecessary since we update value).
          // The initial value can be a boolean or object so that's why it's
          // forced to be a string.
          initialValue: "" + (value != null ? value : defaultValue),
          value: defaultValue
        };
      },
      shouldComponentUpdate: function() {
        return !this._isChanging;
      },
      render: function() {
        var props = merge(this.props);
        var value = LinkedValueUtils.getValue(this);
        require_React().__DEV__ === true ? invariant(
          props.dangerouslySetInnerHTML == null,
          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
        ) : invariant(props.dangerouslySetInnerHTML == null);
        props.defaultValue = null;
        props.value = value != null ? value : this.state.value;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue);
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          var rootNode = this.getDOMNode();
          DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          this._isChanging = true;
          returnValue = onChange.call(this, event);
          this._isChanging = false;
        }
        this.setState({ value: event.target.value });
        return returnValue;
      }
    });
    module.exports = ReactDOMTextarea;
  }
});

// node_modules/react-component/lib/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/react-component/lib/shallowEqual.js"(exports, module) {
    "use strict";
    function shallowEqual(objA, objB) {
      if (objA === objB) {
        return true;
      }
      var key;
      for (key in objA) {
        if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
          return false;
        }
      }
      for (key in objB) {
        if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    module.exports = shallowEqual;
  }
});

// node_modules/react-component/lib/SelectEventPlugin.js
var require_SelectEventPlugin = __commonJS({
  "node_modules/react-component/lib/SelectEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPropagators = require_EventPropagators();
    var ReactInputSelection = require_ReactInputSelection();
    var SyntheticEvent = require_SyntheticEvent();
    var getActiveElement = require_getActiveElement();
    var isTextInputElement = require_isTextInputElement();
    var keyOf = require_keyOf();
    var shallowEqual = require_shallowEqual();
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      select: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onSelect: null }),
          captured: keyOf({ onSelectCapture: null })
        },
        dependencies: [
          topLevelTypes.topBlur,
          topLevelTypes.topContextMenu,
          topLevelTypes.topFocus,
          topLevelTypes.topKeyDown,
          topLevelTypes.topMouseDown,
          topLevelTypes.topMouseUp,
          topLevelTypes.topSelectionChange
        ]
      }
    };
    var activeElement = null;
    var activeElementID = null;
    var lastSelection = null;
    var mouseDown = false;
    function getSelection(node) {
      if ("selectionStart" in node && ReactInputSelection.hasSelectionCapabilities(node)) {
        return {
          start: node.selectionStart,
          end: node.selectionEnd
        };
      } else if (document.selection) {
        var range = document.selection.createRange();
        return {
          parentElement: range.parentElement(),
          text: range.text,
          top: range.boundingTop,
          left: range.boundingLeft
        };
      } else {
        var selection = window.getSelection();
        return {
          anchorNode: selection.anchorNode,
          anchorOffset: selection.anchorOffset,
          focusNode: selection.focusNode,
          focusOffset: selection.focusOffset
        };
      }
    }
    function constructSelectEvent(nativeEvent) {
      if (mouseDown || activeElement == null || activeElement != getActiveElement()) {
        return;
      }
      var currentSelection = getSelection(activeElement);
      if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
        lastSelection = currentSelection;
        var syntheticEvent = SyntheticEvent.getPooled(
          eventTypes.select,
          activeElementID,
          nativeEvent
        );
        syntheticEvent.type = "select";
        syntheticEvent.target = activeElement;
        EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
        return syntheticEvent;
      }
    }
    var SelectEventPlugin = {
      eventTypes,
      /**
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        switch (topLevelType) {
          case topLevelTypes.topFocus:
            if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === "true") {
              activeElement = topLevelTarget;
              activeElementID = topLevelTargetID;
              lastSelection = null;
            }
            break;
          case topLevelTypes.topBlur:
            activeElement = null;
            activeElementID = null;
            lastSelection = null;
            break;
          case topLevelTypes.topMouseDown:
            mouseDown = true;
            break;
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topMouseUp:
            mouseDown = false;
            return constructSelectEvent(nativeEvent);
          case topLevelTypes.topSelectionChange:
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            return constructSelectEvent(nativeEvent);
        }
      }
    };
    module.exports = SelectEventPlugin;
  }
});

// node_modules/react-component/lib/ServerReactRootIndex.js
var require_ServerReactRootIndex = __commonJS({
  "node_modules/react-component/lib/ServerReactRootIndex.js"(exports, module) {
    "use strict";
    var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
    var ServerReactRootIndex = {
      createReactRootIndex: function() {
        return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
      }
    };
    module.exports = ServerReactRootIndex;
  }
});

// node_modules/react-component/lib/SyntheticClipboardEvent.js
var require_SyntheticClipboardEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticClipboardEvent.js"(exports, module) {
    "use strict";
    var SyntheticEvent = require_SyntheticEvent();
    var ClipboardEventInterface = {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    };
    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
    module.exports = SyntheticClipboardEvent;
  }
});

// node_modules/react-component/lib/SyntheticFocusEvent.js
var require_SyntheticFocusEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticFocusEvent.js"(exports, module) {
    "use strict";
    var SyntheticUIEvent = require_SyntheticUIEvent();
    var FocusEventInterface = {
      relatedTarget: null
    };
    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
    module.exports = SyntheticFocusEvent;
  }
});

// node_modules/react-component/lib/getEventKey.js
var require_getEventKey = __commonJS({
  "node_modules/react-component/lib/getEventKey.js"(exports, module) {
    "use strict";
    var normalizeKey = {
      "Esc": "Escape",
      "Spacebar": " ",
      "Left": "ArrowLeft",
      "Up": "ArrowUp",
      "Right": "ArrowRight",
      "Down": "ArrowDown",
      "Del": "Delete",
      "Win": "OS",
      "Menu": "ContextMenu",
      "Apps": "ContextMenu",
      "Scroll": "ScrollLock",
      "MozPrintableKey": "Unidentified"
    };
    var translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function getEventKey(nativeEvent) {
      return "key" in nativeEvent ? normalizeKey[nativeEvent.key] || nativeEvent.key : translateToKey[nativeEvent.which || nativeEvent.keyCode] || "Unidentified";
    }
    module.exports = getEventKey;
  }
});

// node_modules/react-component/lib/SyntheticKeyboardEvent.js
var require_SyntheticKeyboardEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticKeyboardEvent.js"(exports, module) {
    "use strict";
    var SyntheticUIEvent = require_SyntheticUIEvent();
    var getEventKey = require_getEventKey();
    var KeyboardEventInterface = {
      key: getEventKey,
      location: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      repeat: null,
      locale: null,
      // Legacy Interface
      "char": null,
      charCode: null,
      keyCode: null,
      which: null
    };
    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
    module.exports = SyntheticKeyboardEvent;
  }
});

// node_modules/react-component/lib/SyntheticDragEvent.js
var require_SyntheticDragEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticDragEvent.js"(exports, module) {
    "use strict";
    var SyntheticMouseEvent = require_SyntheticMouseEvent();
    var DragEventInterface = {
      dataTransfer: null
    };
    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
    module.exports = SyntheticDragEvent;
  }
});

// node_modules/react-component/lib/SyntheticTouchEvent.js
var require_SyntheticTouchEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticTouchEvent.js"(exports, module) {
    "use strict";
    var SyntheticUIEvent = require_SyntheticUIEvent();
    var TouchEventInterface = {
      touches: null,
      targetTouches: null,
      changedTouches: null,
      altKey: null,
      metaKey: null,
      ctrlKey: null,
      shiftKey: null
    };
    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
    module.exports = SyntheticTouchEvent;
  }
});

// node_modules/react-component/lib/SyntheticWheelEvent.js
var require_SyntheticWheelEvent = __commonJS({
  "node_modules/react-component/lib/SyntheticWheelEvent.js"(exports, module) {
    "use strict";
    var SyntheticMouseEvent = require_SyntheticMouseEvent();
    var WheelEventInterface = {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in event ? -event.wheelDeltaX : 0
        );
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in event ? -event.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in event ? -event.wheelDelta : 0
          )
        );
      },
      deltaZ: null,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: null
    };
    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
      SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
    }
    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
    module.exports = SyntheticWheelEvent;
  }
});

// node_modules/react-component/lib/SimpleEventPlugin.js
var require_SimpleEventPlugin = __commonJS({
  "node_modules/react-component/lib/SimpleEventPlugin.js"(exports, module) {
    "use strict";
    var EventConstants = require_EventConstants();
    var EventPluginUtils = require_EventPluginUtils();
    var EventPropagators = require_EventPropagators();
    var SyntheticClipboardEvent = require_SyntheticClipboardEvent();
    var SyntheticEvent = require_SyntheticEvent();
    var SyntheticFocusEvent = require_SyntheticFocusEvent();
    var SyntheticKeyboardEvent = require_SyntheticKeyboardEvent();
    var SyntheticMouseEvent = require_SyntheticMouseEvent();
    var SyntheticDragEvent = require_SyntheticDragEvent();
    var SyntheticTouchEvent = require_SyntheticTouchEvent();
    var SyntheticUIEvent = require_SyntheticUIEvent();
    var SyntheticWheelEvent = require_SyntheticWheelEvent();
    var invariant = require_invariant();
    var keyOf = require_keyOf();
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      blur: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onBlur: true }),
          captured: keyOf({ onBlurCapture: true })
        }
      },
      click: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onClick: true }),
          captured: keyOf({ onClickCapture: true })
        }
      },
      contextMenu: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onContextMenu: true }),
          captured: keyOf({ onContextMenuCapture: true })
        }
      },
      copy: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onCopy: true }),
          captured: keyOf({ onCopyCapture: true })
        }
      },
      cut: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onCut: true }),
          captured: keyOf({ onCutCapture: true })
        }
      },
      doubleClick: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDoubleClick: true }),
          captured: keyOf({ onDoubleClickCapture: true })
        }
      },
      drag: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDrag: true }),
          captured: keyOf({ onDragCapture: true })
        }
      },
      dragEnd: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragEnd: true }),
          captured: keyOf({ onDragEndCapture: true })
        }
      },
      dragEnter: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragEnter: true }),
          captured: keyOf({ onDragEnterCapture: true })
        }
      },
      dragExit: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragExit: true }),
          captured: keyOf({ onDragExitCapture: true })
        }
      },
      dragLeave: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragLeave: true }),
          captured: keyOf({ onDragLeaveCapture: true })
        }
      },
      dragOver: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragOver: true }),
          captured: keyOf({ onDragOverCapture: true })
        }
      },
      dragStart: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDragStart: true }),
          captured: keyOf({ onDragStartCapture: true })
        }
      },
      drop: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onDrop: true }),
          captured: keyOf({ onDropCapture: true })
        }
      },
      focus: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onFocus: true }),
          captured: keyOf({ onFocusCapture: true })
        }
      },
      input: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onInput: true }),
          captured: keyOf({ onInputCapture: true })
        }
      },
      keyDown: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onKeyDown: true }),
          captured: keyOf({ onKeyDownCapture: true })
        }
      },
      keyPress: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onKeyPress: true }),
          captured: keyOf({ onKeyPressCapture: true })
        }
      },
      keyUp: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onKeyUp: true }),
          captured: keyOf({ onKeyUpCapture: true })
        }
      },
      load: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onLoad: true }),
          captured: keyOf({ onLoadCapture: true })
        }
      },
      error: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onError: true }),
          captured: keyOf({ onErrorCapture: true })
        }
      },
      // Note: We do not allow listening to mouseOver events. Instead, use the
      // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
      mouseDown: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onMouseDown: true }),
          captured: keyOf({ onMouseDownCapture: true })
        }
      },
      mouseMove: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onMouseMove: true }),
          captured: keyOf({ onMouseMoveCapture: true })
        }
      },
      mouseOut: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onMouseOut: true }),
          captured: keyOf({ onMouseOutCapture: true })
        }
      },
      mouseOver: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onMouseOver: true }),
          captured: keyOf({ onMouseOverCapture: true })
        }
      },
      mouseUp: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onMouseUp: true }),
          captured: keyOf({ onMouseUpCapture: true })
        }
      },
      paste: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onPaste: true }),
          captured: keyOf({ onPasteCapture: true })
        }
      },
      reset: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onReset: true }),
          captured: keyOf({ onResetCapture: true })
        }
      },
      scroll: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onScroll: true }),
          captured: keyOf({ onScrollCapture: true })
        }
      },
      submit: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onSubmit: true }),
          captured: keyOf({ onSubmitCapture: true })
        }
      },
      touchCancel: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onTouchCancel: true }),
          captured: keyOf({ onTouchCancelCapture: true })
        }
      },
      touchEnd: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onTouchEnd: true }),
          captured: keyOf({ onTouchEndCapture: true })
        }
      },
      touchMove: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onTouchMove: true }),
          captured: keyOf({ onTouchMoveCapture: true })
        }
      },
      touchStart: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onTouchStart: true }),
          captured: keyOf({ onTouchStartCapture: true })
        }
      },
      wheel: {
        phasedRegistrationNames: {
          bubbled: keyOf({ onWheel: true }),
          captured: keyOf({ onWheelCapture: true })
        }
      }
    };
    var topLevelEventsToDispatchConfig = {
      topBlur: eventTypes.blur,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSubmit: eventTypes.submit,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topWheel: eventTypes.wheel
    };
    for (topLevelType in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
    }
    var topLevelType;
    var SimpleEventPlugin = {
      eventTypes,
      /**
       * Same as the default implementation, except cancels the event when return
       * value is false.
       *
       * @param {object} Event to be dispatched.
       * @param {function} Application-level callback.
       * @param {string} domID DOM ID to pass to the callback.
       */
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      /**
       * @param {string} topLevelType Record from `EventConstants`.
       * @param {DOMEventTarget} topLevelTarget The listening component root node.
       * @param {string} topLevelTargetID ID of `topLevelTarget`.
       * @param {object} nativeEvent Native browser event.
       * @return {*} An accumulation of synthetic events.
       * @see {EventPluginHub.extractEvents}
       */
      extractEvents: function(topLevelType2, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType2];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType2) {
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topError:
          case topLevelTypes.topReset:
          case topLevelTypes.topSubmit:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyPress:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        require_React().__DEV__ === true ? invariant(
          EventConstructor,
          "SimpleEventPlugin: Unhandled event type, `%s`.",
          topLevelType2
        ) : invariant(EventConstructor);
        var event = EventConstructor.getPooled(
          dispatchConfig,
          topLevelTargetID,
          nativeEvent
        );
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    };
    module.exports = SimpleEventPlugin;
  }
});

// node_modules/react-component/lib/ReactDefaultBatchingStrategy.js
var require_ReactDefaultBatchingStrategy = __commonJS({
  "node_modules/react-component/lib/ReactDefaultBatchingStrategy.js"(exports, module) {
    "use strict";
    var ReactUpdates = require_ReactUpdates();
    var Transaction = require_Transaction();
    var emptyFunction = require_emptyFunction();
    var mixInto = require_mixInto();
    var RESET_BATCHED_UPDATES = {
      initialize: emptyFunction,
      close: function() {
        ReactDefaultBatchingStrategy.isBatchingUpdates = false;
      }
    };
    var FLUSH_BATCHED_UPDATES = {
      initialize: emptyFunction,
      close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
    };
    var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
    function ReactDefaultBatchingStrategyTransaction() {
      this.reinitializeTransaction();
    }
    mixInto(ReactDefaultBatchingStrategyTransaction, Transaction.Mixin);
    mixInto(ReactDefaultBatchingStrategyTransaction, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      }
    });
    var transaction = new ReactDefaultBatchingStrategyTransaction();
    var ReactDefaultBatchingStrategy = {
      isBatchingUpdates: false,
      /**
       * Call the provided function in a context within which calls to `setState`
       * and friends are batched such that components aren't updated unnecessarily.
       */
      batchedUpdates: function(callback, param) {
        var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
        ReactDefaultBatchingStrategy.isBatchingUpdates = true;
        if (alreadyBatchingUpdates) {
          callback(param);
        } else {
          transaction.perform(callback, null, param);
        }
      }
    };
    module.exports = ReactDefaultBatchingStrategy;
  }
});

// node_modules/react-component/lib/createFullPageComponent.js
var require_createFullPageComponent = __commonJS({
  "node_modules/react-component/lib/createFullPageComponent.js"(exports, module) {
    "use strict";
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var invariant = require_invariant();
    function createFullPageComponent(componentClass) {
      var FullPageComponent = ReactCompositeComponent.createClass({
        displayName: "ReactFullPageComponent" + (componentClass.componentConstructor.displayName || ""),
        componentWillUnmount: function() {
          require_React().__DEV__ === true ? invariant(
            false,
            "%s tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.",
            this.constructor.displayName
          ) : invariant(false);
        },
        render: function() {
          return this.transferPropsTo(componentClass(null, this.props.children));
        }
      });
      return FullPageComponent;
    }
    module.exports = createFullPageComponent;
  }
});

// node_modules/react-component/lib/ReactDefaultPerfAnalysis.js
var require_ReactDefaultPerfAnalysis = __commonJS({
  "node_modules/react-component/lib/ReactDefaultPerfAnalysis.js"(exports, module) {
    var merge = require_merge();
    var DONT_CARE_THRESHOLD = 1.2;
    var DOM_OPERATION_TYPES = {
      "mountImageIntoNode": "set innerHTML",
      INSERT_MARKUP: "set innerHTML",
      MOVE_EXISTING: "move",
      REMOVE_NODE: "remove",
      TEXT_CONTENT: "set textContent",
      "updatePropertyByID": "update attribute",
      "deletePropertyByID": "delete attribute",
      "updateStylesByID": "update styles",
      "updateInnerHTMLByID": "set innerHTML",
      "dangerouslyReplaceNodeWithMarkupByID": "replace"
    };
    function getTotalTime(measurements) {
      var totalTime = 0;
      for (var i = 0; i < measurements.length; i++) {
        var measurement = measurements[i];
        totalTime += measurement.totalTime;
      }
      return totalTime;
    }
    function getDOMSummary(measurements) {
      var items = [];
      for (var i = 0; i < measurements.length; i++) {
        var measurement = measurements[i];
        var id;
        for (id in measurement.writes) {
          measurement.writes[id].forEach(function(write) {
            items.push({
              id,
              type: DOM_OPERATION_TYPES[write.type] || write.type,
              args: write.args
            });
          });
        }
      }
      return items;
    }
    function getExclusiveSummary(measurements) {
      var candidates = {};
      var displayName;
      for (var i = 0; i < measurements.length; i++) {
        var measurement = measurements[i];
        var allIDs = merge(measurement.exclusive, measurement.inclusive);
        for (var id in allIDs) {
          displayName = measurement.displayNames[id].current;
          candidates[displayName] = candidates[displayName] || {
            componentName: displayName,
            inclusive: 0,
            exclusive: 0,
            count: 0
          };
          if (measurement.exclusive[id]) {
            candidates[displayName].exclusive += measurement.exclusive[id];
          }
          if (measurement.inclusive[id]) {
            candidates[displayName].inclusive += measurement.inclusive[id];
          }
          if (measurement.counts[id]) {
            candidates[displayName].count += measurement.counts[id];
          }
        }
      }
      var arr = [];
      for (displayName in candidates) {
        if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
          arr.push(candidates[displayName]);
        }
      }
      arr.sort(function(a, b) {
        return b.exclusive - a.exclusive;
      });
      return arr;
    }
    function getInclusiveSummary(measurements, onlyClean) {
      var candidates = {};
      var inclusiveKey;
      for (var i = 0; i < measurements.length; i++) {
        var measurement = measurements[i];
        var allIDs = merge(measurement.exclusive, measurement.inclusive);
        var cleanComponents;
        if (onlyClean) {
          cleanComponents = getUnchangedComponents(measurement);
        }
        for (var id in allIDs) {
          if (onlyClean && !cleanComponents[id]) {
            continue;
          }
          var displayName = measurement.displayNames[id];
          inclusiveKey = displayName.owner + " > " + displayName.current;
          candidates[inclusiveKey] = candidates[inclusiveKey] || {
            componentName: inclusiveKey,
            time: 0,
            count: 0
          };
          if (measurement.inclusive[id]) {
            candidates[inclusiveKey].time += measurement.inclusive[id];
          }
          if (measurement.counts[id]) {
            candidates[inclusiveKey].count += measurement.counts[id];
          }
        }
      }
      var arr = [];
      for (inclusiveKey in candidates) {
        if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
          arr.push(candidates[inclusiveKey]);
        }
      }
      arr.sort(function(a, b) {
        return b.time - a.time;
      });
      return arr;
    }
    function getUnchangedComponents(measurement) {
      var cleanComponents = {};
      var dirtyLeafIDs = Object.keys(measurement.writes);
      var allIDs = merge(measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        var isDirty = false;
        for (var i = 0; i < dirtyLeafIDs.length; i++) {
          if (dirtyLeafIDs[i].indexOf(id) === 0) {
            isDirty = true;
            break;
          }
        }
        if (!isDirty && measurement.counts[id] > 0) {
          cleanComponents[id] = true;
        }
      }
      return cleanComponents;
    }
    var ReactDefaultPerfAnalysis = {
      getExclusiveSummary,
      getInclusiveSummary,
      getDOMSummary,
      getTotalTime
    };
    module.exports = ReactDefaultPerfAnalysis;
  }
});

// node_modules/react-component/lib/performanceNow.js
var require_performanceNow = __commonJS({
  "node_modules/react-component/lib/performanceNow.js"(exports, module) {
    "use strict";
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var performance = null;
    if (ExecutionEnvironment.canUseDOM) {
      performance = window.performance || window.webkitPerformance;
    }
    if (!performance || !performance.now) {
      performance = Date;
    }
    var performanceNow = performance.now.bind(performance);
    module.exports = performanceNow;
  }
});

// node_modules/react-component/lib/ReactDefaultPerf.js
var require_ReactDefaultPerf = __commonJS({
  "node_modules/react-component/lib/ReactDefaultPerf.js"(exports, module) {
    "use strict";
    var DOMProperty = require_DOMProperty();
    var ReactDefaultPerfAnalysis = require_ReactDefaultPerfAnalysis();
    var ReactMount = require_ReactMount();
    var ReactPerf = require_ReactPerf();
    var performanceNow = require_performanceNow();
    function roundFloat(val) {
      return Math.floor(val * 100) / 100;
    }
    var ReactDefaultPerf = {
      _allMeasurements: [],
      // last item in the list is the current one
      _injected: false,
      start: function() {
        if (!ReactDefaultPerf._injected) {
          ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
        }
        ReactDefaultPerf._allMeasurements.length = 0;
        ReactPerf.enableMeasure = true;
      },
      stop: function() {
        ReactPerf.enableMeasure = false;
      },
      getLastMeasurements: function() {
        return ReactDefaultPerf._allMeasurements;
      },
      printExclusive: function(measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
        console.table(summary.map(function(item) {
          return {
            "Component class name": item.componentName,
            "Total inclusive time (ms)": roundFloat(item.inclusive),
            "Total exclusive time (ms)": roundFloat(item.exclusive),
            "Exclusive time per instance (ms)": roundFloat(item.exclusive / item.count),
            "Instances": item.count
          };
        }));
        console.log(
          "Total time:",
          ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms"
        );
      },
      printInclusive: function(measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
        console.table(summary.map(function(item) {
          return {
            "Owner > component": item.componentName,
            "Inclusive time (ms)": roundFloat(item.time),
            "Instances": item.count
          };
        }));
        console.log(
          "Total time:",
          ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms"
        );
      },
      printWasted: function(measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(
          measurements,
          true
        );
        console.table(summary.map(function(item) {
          return {
            "Owner > component": item.componentName,
            "Wasted time (ms)": item.time,
            "Instances": item.count
          };
        }));
        console.log(
          "Total time:",
          ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms"
        );
      },
      printDOM: function(measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
        console.table(summary.map(function(item) {
          var result = {};
          result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
          result["type"] = item.type;
          result["args"] = JSON.stringify(item.args);
          return result;
        }));
        console.log(
          "Total time:",
          ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms"
        );
      },
      _recordWrite: function(id, fnName, totalTime, args) {
        var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
        writes[id] = writes[id] || [];
        writes[id].push({
          type: fnName,
          time: totalTime,
          args
        });
      },
      measure: function(moduleName, fnName, func) {
        return function() {
          var args = Array.prototype.slice.call(arguments, 0);
          var totalTime;
          var rv;
          var start;
          if (fnName === "_renderNewRootComponent" || fnName === "flushBatchedUpdates") {
            ReactDefaultPerf._allMeasurements.push({
              exclusive: {},
              inclusive: {},
              counts: {},
              writes: {},
              displayNames: {},
              totalTime: 0
            });
            start = performanceNow();
            rv = func.apply(this, args);
            ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
            return rv;
          } else if (moduleName === "ReactDOMIDOperations" || moduleName === "ReactComponentBrowserEnvironment") {
            start = performanceNow();
            rv = func.apply(this, args);
            totalTime = performanceNow() - start;
            if (fnName === "mountImageIntoNode") {
              var mountID = ReactMount.getID(args[1]);
              ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
            } else if (fnName === "dangerouslyProcessChildrenUpdates") {
              args[0].forEach(function(update) {
                var writeArgs = {};
                if (update.fromIndex !== null) {
                  writeArgs.fromIndex = update.fromIndex;
                }
                if (update.toIndex !== null) {
                  writeArgs.toIndex = update.toIndex;
                }
                if (update.textContent !== null) {
                  writeArgs.textContent = update.textContent;
                }
                if (update.markupIndex !== null) {
                  writeArgs.markup = args[1][update.markupIndex];
                }
                ReactDefaultPerf._recordWrite(
                  update.parentID,
                  update.type,
                  totalTime,
                  writeArgs
                );
              });
            } else {
              ReactDefaultPerf._recordWrite(
                args[0],
                fnName,
                totalTime,
                Array.prototype.slice.call(args, 1)
              );
            }
            return rv;
          } else if (moduleName === "ReactCompositeComponent" && (fnName === "mountComponent" || fnName === "updateComponent" || // TODO: receiveComponent()?
          fnName === "_renderValidatedComponent")) {
            var rootNodeID = fnName === "mountComponent" ? args[0] : this._rootNodeID;
            var isRender = fnName === "_renderValidatedComponent";
            var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
            if (isRender) {
              entry.counts[rootNodeID] = entry.counts[rootNodeID] || 0;
              entry.counts[rootNodeID] += 1;
            }
            start = performanceNow();
            rv = func.apply(this, args);
            totalTime = performanceNow() - start;
            var typeOfLog = isRender ? entry.exclusive : entry.inclusive;
            typeOfLog[rootNodeID] = typeOfLog[rootNodeID] || 0;
            typeOfLog[rootNodeID] += totalTime;
            entry.displayNames[rootNodeID] = {
              current: this.constructor.displayName,
              owner: this._owner ? this._owner.constructor.displayName : "<root>"
            };
            return rv;
          } else {
            return func.apply(this, args);
          }
        };
      }
    };
    module.exports = ReactDefaultPerf;
  }
});

// node_modules/react-component/lib/ReactDefaultInjection.js
var require_ReactDefaultInjection = __commonJS({
  "node_modules/react-component/lib/ReactDefaultInjection.js"(exports, module) {
    "use strict";
    var ReactInjection = require_ReactInjection();
    var ExecutionEnvironment = require_ExecutionEnvironment();
    var DefaultDOMPropertyConfig = require_DefaultDOMPropertyConfig();
    var ChangeEventPlugin = require_ChangeEventPlugin();
    var ClientReactRootIndex = require_ClientReactRootIndex();
    var CompositionEventPlugin = require_CompositionEventPlugin();
    var DefaultEventPluginOrder = require_DefaultEventPluginOrder();
    var EnterLeaveEventPlugin = require_EnterLeaveEventPlugin();
    var MobileSafariClickEventPlugin = require_MobileSafariClickEventPlugin();
    var ReactBrowserComponentMixin = require_ReactBrowserComponentMixin();
    var ReactComponentBrowserEnvironment = require_ReactComponentBrowserEnvironment();
    var ReactEventTopLevelCallback = require_ReactEventTopLevelCallback();
    var ReactDOM = require_ReactDOM();
    var ReactDOMButton = require_ReactDOMButton();
    var ReactDOMForm = require_ReactDOMForm();
    var ReactDOMImg = require_ReactDOMImg();
    var ReactDOMInput = require_ReactDOMInput();
    var ReactDOMOption = require_ReactDOMOption();
    var ReactDOMSelect = require_ReactDOMSelect();
    var ReactDOMTextarea = require_ReactDOMTextarea();
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactMount = require_ReactMount();
    var SelectEventPlugin = require_SelectEventPlugin();
    var ServerReactRootIndex = require_ServerReactRootIndex();
    var SimpleEventPlugin = require_SimpleEventPlugin();
    var ReactDefaultBatchingStrategy = require_ReactDefaultBatchingStrategy();
    var createFullPageComponent = require_createFullPageComponent();
    function inject() {
      ReactInjection.EventEmitter.injectTopLevelCallbackCreator(
        ReactEventTopLevelCallback
      );
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin,
        EnterLeaveEventPlugin,
        ChangeEventPlugin,
        CompositionEventPlugin,
        MobileSafariClickEventPlugin,
        SelectEventPlugin
      });
      ReactInjection.DOM.injectComponentClasses({
        button: ReactDOMButton,
        form: ReactDOMForm,
        img: ReactDOMImg,
        input: ReactDOMInput,
        option: ReactDOMOption,
        select: ReactDOMSelect,
        textarea: ReactDOMTextarea,
        html: createFullPageComponent(ReactDOM.html),
        head: createFullPageComponent(ReactDOM.head),
        title: createFullPageComponent(ReactDOM.title),
        body: createFullPageComponent(ReactDOM.body)
      });
      ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(DefaultDOMPropertyConfig);
      ReactInjection.Updates.injectBatchingStrategy(
        ReactDefaultBatchingStrategy
      );
      ReactInjection.RootIndex.injectCreateReactRootIndex(
        ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex
      );
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      if (require_React().__DEV__ === true) {
        var url = ExecutionEnvironment.canUseDOM && window.location.href || "";
        if (/[?&]react_perf\b/.test(url)) {
          var ReactDefaultPerf = require_ReactDefaultPerf();
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {
      inject
    };
  }
});

// node_modules/react-component/lib/ReactServerRenderingTransaction.js
var require_ReactServerRenderingTransaction = __commonJS({
  "node_modules/react-component/lib/ReactServerRenderingTransaction.js"(exports, module) {
    "use strict";
    var PooledClass = require_PooledClass();
    var ReactMountReady = require_ReactMountReady();
    var ReactPutListenerQueue = require_ReactPutListenerQueue();
    var Transaction = require_Transaction();
    var emptyFunction = require_emptyFunction();
    var mixInto = require_mixInto();
    var ON_DOM_READY_QUEUEING = {
      /**
       * Initializes the internal `onDOMReady` queue.
       */
      initialize: function() {
        this.reactMountReady.reset();
      },
      close: emptyFunction
    };
    var PUT_LISTENER_QUEUEING = {
      initialize: function() {
        this.putListenerQueue.reset();
      },
      close: emptyFunction
    };
    var TRANSACTION_WRAPPERS = [
      PUT_LISTENER_QUEUEING,
      ON_DOM_READY_QUEUEING
    ];
    function ReactServerRenderingTransaction(renderToStaticMarkup) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = renderToStaticMarkup;
      this.reactMountReady = ReactMountReady.getPooled(null);
      this.putListenerQueue = ReactPutListenerQueue.getPooled();
    }
    var Mixin = {
      /**
       * @see Transaction
       * @abstract
       * @final
       * @return {array} Empty list of operation wrap proceedures.
       */
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      /**
       * @return {object} The queue to collect `onDOMReady` callbacks with.
       *   TODO: convert to ReactMountReady
       */
      getReactMountReady: function() {
        return this.reactMountReady;
      },
      getPutListenerQueue: function() {
        return this.putListenerQueue;
      },
      /**
       * `PooledClass` looks for this, and will invoke this before allowing this
       * instance to be resused.
       */
      destructor: function() {
        ReactMountReady.release(this.reactMountReady);
        this.reactMountReady = null;
        ReactPutListenerQueue.release(this.putListenerQueue);
        this.putListenerQueue = null;
      }
    };
    mixInto(ReactServerRenderingTransaction, Transaction.Mixin);
    mixInto(ReactServerRenderingTransaction, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction;
  }
});

// node_modules/react-component/lib/ReactServerRendering.js
var require_ReactServerRendering = __commonJS({
  "node_modules/react-component/lib/ReactServerRendering.js"(exports, module) {
    "use strict";
    var ReactComponent = require_ReactComponent();
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactMarkupChecksum = require_ReactMarkupChecksum();
    var ReactServerRenderingTransaction = require_ReactServerRenderingTransaction();
    var instantiateReactComponent = require_instantiateReactComponent();
    var invariant = require_invariant();
    function renderComponentToString(component) {
      require_React().__DEV__ === true ? invariant(
        ReactComponent.isValidComponent(component),
        "renderComponentToString(): You must pass a valid ReactComponent."
      ) : invariant(ReactComponent.isValidComponent(component));
      require_React().__DEV__ === true ? invariant(
        !(arguments.length === 2 && typeof arguments[1] === "function"),
        "renderComponentToString(): This function became synchronous and now returns the generated markup. Please remove the second parameter."
      ) : invariant(!(arguments.length === 2 && typeof arguments[1] === "function"));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(component);
          var markup = componentInstance.mountComponent(id, transaction, 0);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    function renderComponentToStaticMarkup(component) {
      require_React().__DEV__ === true ? invariant(
        ReactComponent.isValidComponent(component),
        "renderComponentToStaticMarkup(): You must pass a valid ReactComponent."
      ) : invariant(ReactComponent.isValidComponent(component));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(component);
          return componentInstance.mountComponent(id, transaction, 0);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    module.exports = {
      renderComponentToString,
      renderComponentToStaticMarkup
    };
  }
});

// node_modules/react-component/lib/onlyChild.js
var require_onlyChild = __commonJS({
  "node_modules/react-component/lib/onlyChild.js"(exports, module) {
    "use strict";
    var ReactComponent = require_ReactComponent();
    var invariant = require_invariant();
    function onlyChild(children) {
      require_React().__DEV__ === true ? invariant(
        ReactComponent.isValidComponent(children),
        "onlyChild must be passed a children with exactly one child."
      ) : invariant(ReactComponent.isValidComponent(children));
      return children;
    }
    module.exports = onlyChild;
  }
});

// node_modules/react-component/lib/React.js
var require_React = __commonJS({
  "node_modules/react-component/lib/React.js"(exports, module) {
    "use strict";
    var DOMPropertyOperations = require_DOMPropertyOperations();
    var EventPluginUtils = require_EventPluginUtils();
    var ReactChildren = require_ReactChildren();
    var ReactComponent = require_ReactComponent();
    var ReactCompositeComponent = require_ReactCompositeComponent();
    var ReactContext = require_ReactContext();
    var ReactCurrentOwner = require_ReactCurrentOwner();
    var ReactDOM = require_ReactDOM();
    var ReactDOMComponent = require_ReactDOMComponent();
    var ReactDefaultInjection = require_ReactDefaultInjection();
    var ReactInstanceHandles = require_ReactInstanceHandles();
    var ReactMount = require_ReactMount();
    var ReactMultiChild = require_ReactMultiChild();
    var ReactPerf = require_ReactPerf();
    var ReactPropTypes = require_ReactPropTypes();
    var ReactServerRendering = require_ReactServerRendering();
    var ReactTextComponent = require_ReactTextComponent();
    var onlyChild = require_onlyChild();
    ReactDefaultInjection.inject();
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        only: onlyChild
      },
      DOM: ReactDOM,
      PropTypes: ReactPropTypes,
      initializeTouchEvents: function(shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch;
      },
      createClass: ReactCompositeComponent.createClass,
      constructAndRenderComponent: ReactMount.constructAndRenderComponent,
      constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
      renderComponent: ReactPerf.measure(
        "React",
        "renderComponent",
        ReactMount.renderComponent
      ),
      renderComponentToString: ReactServerRendering.renderComponentToString,
      renderComponentToStaticMarkup: ReactServerRendering.renderComponentToStaticMarkup,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      isValidClass: ReactCompositeComponent.isValidClass,
      isValidComponent: ReactComponent.isValidComponent,
      withContext: ReactContext.withContext,
      __internals: {
        Component: ReactComponent,
        CurrentOwner: ReactCurrentOwner,
        DOMComponent: ReactDOMComponent,
        DOMPropertyOperations,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        MultiChild: ReactMultiChild,
        TextComponent: ReactTextComponent
      }
    };
    if (require_React().__DEV__ === true) {
      ExecutionEnvironment = require_ExecutionEnvironment();
      if (ExecutionEnvironment.canUseDOM && window.top === window.self && navigator.userAgent.indexOf("Chrome") > -1) {
        console.debug(
          "Download the React DevTools for a better development experience: http://fb.me/react-devtools"
        );
      }
    }
    var ExecutionEnvironment;
    React.version = "0.10.0";
    module.exports = React;
  }
});

// node_modules/react-component/lib/invariant.js
var require_invariant = __commonJS({
  "node_modules/react-component/lib/invariant.js"(exports, module) {
    "use strict";
    var invariant = function(condition) {
      if (!condition) {
        var error = new Error(
          "Minified exception occured; use the non-minified dev environment for the full error message and additional helpful warnings."
        );
        error.framesToPop = 1;
        throw error;
      }
    };
    if (require_React().__DEV__ === true) {
      invariant = function(condition, format, a, b, c, d, e, f) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
        if (!condition) {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          var error = new Error(
            "Invariant Violation: " + format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.framesToPop = 1;
          throw error;
        }
      };
    }
    module.exports = invariant;
  }
});

// node_modules/react-component/lib/mergeHelpers.js
var require_mergeHelpers = __commonJS({
  "node_modules/react-component/lib/mergeHelpers.js"(exports, module) {
    "use strict";
    var invariant = require_invariant();
    var keyMirror = require_keyMirror();
    var MAX_MERGE_DEPTH = 36;
    var isTerminal = function(o) {
      return typeof o !== "object" || o === null;
    };
    var mergeHelpers = {
      MAX_MERGE_DEPTH,
      isTerminal,
      /**
       * Converts null/undefined values into empty object.
       *
       * @param {?Object=} arg Argument to be normalized (nullable optional)
       * @return {!Object}
       */
      normalizeMergeArg: function(arg) {
        return arg === void 0 || arg === null ? {} : arg;
      },
      /**
       * If merging Arrays, a merge strategy *must* be supplied. If not, it is
       * likely the caller's fault. If this function is ever called with anything
       * but `one` and `two` being `Array`s, it is the fault of the merge utilities.
       *
       * @param {*} one Array to merge into.
       * @param {*} two Array to merge from.
       */
      checkMergeArrayArgs: function(one, two) {
        require_React().__DEV__ === true ? invariant(
          Array.isArray(one) && Array.isArray(two),
          "Tried to merge arrays, instead got %s and %s.",
          one,
          two
        ) : invariant(Array.isArray(one) && Array.isArray(two));
      },
      /**
       * @param {*} one Object to merge into.
       * @param {*} two Object to merge from.
       */
      checkMergeObjectArgs: function(one, two) {
        mergeHelpers.checkMergeObjectArg(one);
        mergeHelpers.checkMergeObjectArg(two);
      },
      /**
       * @param {*} arg
       */
      checkMergeObjectArg: function(arg) {
        require_React().__DEV__ === true ? invariant(
          !isTerminal(arg) && !Array.isArray(arg),
          "Tried to merge an object, instead got %s.",
          arg
        ) : invariant(!isTerminal(arg) && !Array.isArray(arg));
      },
      /**
       * Checks that a merge was not given a circular object or an object that had
       * too great of depth.
       *
       * @param {number} Level of recursion to validate against maximum.
       */
      checkMergeLevel: function(level) {
        require_React().__DEV__ === true ? invariant(
          level < MAX_MERGE_DEPTH,
          "Maximum deep merge depth exceeded. You may be attempting to merge circular structures in an unsupported way."
        ) : invariant(level < MAX_MERGE_DEPTH);
      },
      /**
       * Checks that the supplied merge strategy is valid.
       *
       * @param {string} Array merge strategy.
       */
      checkArrayStrategy: function(strategy) {
        require_React().__DEV__ === true ? invariant(
          strategy === void 0 || strategy in mergeHelpers.ArrayStrategies,
          "You must provide an array strategy to deep merge functions to instruct the deep merge how to resolve merging two arrays."
        ) : invariant(strategy === void 0 || strategy in mergeHelpers.ArrayStrategies);
      },
      /**
       * Set of possible behaviors of merge algorithms when encountering two Arrays
       * that must be merged together.
       * - `clobber`: The left `Array` is ignored.
       * - `indexByIndex`: The result is achieved by recursively deep merging at
       *   each index. (not yet supported.)
       */
      ArrayStrategies: keyMirror({
        Clobber: true,
        IndexByIndex: true
      })
    };
    module.exports = mergeHelpers;
  }
});

// node_modules/react-component/lib/mergeInto.js
var require_mergeInto = __commonJS({
  "node_modules/react-component/lib/mergeInto.js"(exports, module) {
    "use strict";
    var mergeHelpers = require_mergeHelpers();
    var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
    function mergeInto(one, two) {
      checkMergeObjectArg(one);
      if (two != null) {
        checkMergeObjectArg(two);
        for (var key in two) {
          if (!two.hasOwnProperty(key)) {
            continue;
          }
          one[key] = two[key];
        }
      }
    }
    module.exports = mergeInto;
  }
});

// node_modules/react-component/lib/merge.js
var require_merge = __commonJS({
  "node_modules/react-component/lib/merge.js"(exports, module) {
    "use strict";
    var mergeInto = require_mergeInto();
    var merge = function(one, two) {
      var result = {};
      mergeInto(result, one);
      mergeInto(result, two);
      return result;
    };
    module.exports = merge;
  }
});

// node_modules/react-component/lib/ReactContext.js
var require_ReactContext = __commonJS({
  "node_modules/react-component/lib/ReactContext.js"(exports, module) {
    var merge = require_merge();
    var ReactContext = {
      /**
       * @internal
       * @type {object}
       */
      current: {},
      /**
       * Temporarily extends the current context while executing scopedCallback.
       *
       * A typical use case might look like
       *
       *  render: function() {
       *    var children = ReactContext.withContext({foo: 'foo'} () => (
       *
       *    ));
       *    return <div>{children}</div>;
       *  }
       *
       * @param {object} newContext New context to merge into the existing context
       * @param {function} scopedCallback Callback to run with the new context
       * @return {ReactComponent|array<ReactComponent>}
       */
      withContext: function(newContext, scopedCallback) {
        var result;
        var previousContext = ReactContext.current;
        ReactContext.current = merge(previousContext, newContext);
        try {
          result = scopedCallback();
        } finally {
          ReactContext.current = previousContext;
        }
        return result;
      }
    };
    module.exports = ReactContext;
  }
});
export default require_ReactContext();
/*! Bundled license information:

react-component/lib/isEventSupported.js:
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)
*/
//# sourceMappingURL=react-component_lib_ReactContext.js.map
